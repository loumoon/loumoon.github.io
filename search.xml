<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java异常</title>
      <link href="/2021/03/12/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
      <url>/2021/03/12/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Java异常</strong>机制，是程序运行不正常时的处理方式。具体来说，异常机制提供了<strong>程序安全退出的通道</strong>。当异常发生时，程序的执行流程改变，<strong>程序控制权转移到异常处理器</strong>。</p></blockquote><a id="more"></a><h3 id="一、Java异常继承体系"><a href="#一、Java异常继承体系" class="headerlink" title="一、Java异常继承体系"></a>一、Java异常继承体系</h3><p>Java异常类的<strong>继承体系</strong>如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goh4qnwyl4j30hk0mh43v.jpg" alt></p><p><strong>Throwable</strong>类是整个Java异常体系的超类，包括错误Error和异常Exception两个子类。</p><ul><li><strong>Error</strong>表示程序在运行期间出现了十分严重、不可恢复的<strong>错误</strong>，这种情况下应用程序只能终止运行，比如JVM出现错误（VirtualMachineError）。应用程序<strong>一般不捕获Error</strong>，因为它是应用程序所无法处理的情况。</li><li><strong>Exception</strong>是应用程序可以处理的异常，<strong>可以选择</strong>对其进行捕获并处理，包含<strong>运行时异常（RuntimeException）</strong>和<strong>非运行时异常（除RuntimeException外的其他异常）</strong>。<ul><li><strong>运行时异常RuntimeException</strong>是在程序运行时出现的异常，一般是由程序的逻辑错误所引起的，<strong>可以选择捕获处理，也可以不捕获处理</strong>。比如NullPointerException、IndexOutOfBoundsException等。</li><li><strong>非运行时异常</strong>也叫<strong>受检异常</strong>，<strong>必须</strong>在应用程序中对其进行<strong>捕获处理</strong>或者<strong>向上抛出</strong>，否则<strong>无法通过编译器检查</strong>。比如IOException、ClassNotFoundException等。方法内部如果抛出了受检异常，则必须在方法头部声明抛出该受检异常类型。</li></ul></li></ul><p>用户可以在在Java异常体系的基础上<strong>自定义类异常类型</strong>，自定义异常类型要遵循以下原则：</p><ul><li>自定义异常类必须是Throwable的子类。</li><li>如果想自定义一个<strong>受检异常类</strong>，需要<strong>继承Exception类</strong>。</li><li>如果想自定义一个<strong>运行时异常类</strong>，需要<strong>继承RuntimeException类</strong>。</li></ul><h3 id="二、异常的抛出与捕获处理"><a href="#二、异常的抛出与捕获处理" class="headerlink" title="二、异常的抛出与捕获处理"></a>二、异常的抛出与捕获处理</h3><h4 id="1-异常抛出（throw、throws）"><a href="#1-异常抛出（throw、throws）" class="headerlink" title="1.异常抛出（throw、throws）"></a>1.异常抛出（throw、throws）</h4><p><strong>throw</strong>关键字用于<strong>方法体内部</strong>，用来抛出异常。如果抛出的是一个<strong>受检异常</strong>，那么还应该<strong>在方法头部用throws声明抛出的受检异常类型</strong>，该方法的<strong>调用者</strong>也必须<strong>捕获处理</strong>或者<strong>向上抛出</strong>这个受检异常。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-异常捕获处理（try…catch…finally"><a href="#2-异常捕获处理（try…catch…finally" class="headerlink" title="2.异常捕获处理（try…catch…finally)"></a>2.异常捕获处理（try…catch…finally)</h4><p>try代码块中某位置抛出了异常，则该位置之后的代码再也没有机会被执行。</p><p>catch可以有多个，一个try代码块后面跟随多个catch代码块的情况叫<strong>多重捕获</strong>，根据异常的类型<strong>从上往下匹配</strong>，如果有匹配的catch，下面的所有catch会被全部忽略。</p><p>多重捕获下要先catch子类异常再catch父类异常，即<strong>子类异常的catch块在父类异常catch块的上面</strong>。如果顺序反了的话，那么根据Java继承思想，<strong>所有子类异常对象都是父类异常对象</strong>，导致父类异常永远先被捕获到，而捕获子类异常的catch块永远得不到执行，出现<strong>编译错误</strong>。比如下面的代码：（ArithmeticException是Exception的子类，属于受检异常）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionErrorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            numbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            numbers[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">            numbers[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">            numbers[<span class="number">3</span>] = numbers[<span class="number">2</span>] / <span class="number">0</span>;<span class="comment">//会抛出算术运算异常;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论try代码块中是否发生异常，<strong>finally代码块都会被执行</strong>。通常可以在finally块中进行资源的回收工作，比如关闭打开的文件、删除临时文件等。</p><p>如果try、catch块中有return语句，会先把返回值<strong>压栈</strong>，然后再执行finally语句，<strong>执行完finally语句后再返回</strong>。即使在finally中更改了要返回的变量的值，程序依然会返回之前已经压栈的值，而不是在finally中更新后的值。当然，如果try、catch中返回的变量是一个<strong>对象引用</strong>而非基本类型，由于引用已经压栈无法更改，可以通过在finally块中更改引用指向的对象的内容，来影响返回结果。如果finally中有return语句，那么直接忽略try、catch中的return语句，<strong>只执行finally的return</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的类加载器</title>
      <link href="/2021/03/10/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2021/03/10/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回顾<a href="https://loumoon.github.io/2021/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">JVM类加载机制</a>，共分为加载、链接和初始化三个阶段，其中加载阶段做的第一件事，即通过一个类的全限定名来获取此类的二进制字节流，就是<strong>类加载器</strong>要做的事情。所以<strong>类加载器就是JVM通过一个类的全限定名来获取该类的二进制字节流的代码块。</strong></p></blockquote><a id="more"></a><p>JVM类加载器的<strong>双亲委派模型</strong>，如下图所示。类加载器之间的父子关系并不是父类和子类的<strong>继承</strong>关系，而是通过使用<strong>组合</strong>来实现<strong>复用</strong>父加载器的代码。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogaksjglij30pq0hi42g.jpg" alt></p><h4 id="1-启动类加载器（Bootstrap-ClassLoader）"><a href="#1-启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="1.启动类加载器（Bootstrap ClassLoader）"></a>1.启动类加载器（Bootstrap ClassLoader）</h4><p>也叫根类加载器，负责加载Java的<strong>核心类库</strong>，即<strong>JAVA_HOME/jre/lib目录</strong>下的jar包，比如rt.jar（包含System、String这样的核心类）等。启动类加载器是<strong>C++实现</strong>的，并不是Java实现，因此它不是java.lang.ClassLoader的子类。</p><h4 id="2-扩展类加载器（Extension-ClassLoader）"><a href="#2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="2.扩展类加载器（Extension ClassLoader）"></a>2.扩展类加载器（Extension ClassLoader）</h4><p>负责加载<strong>扩展目录%JAVA_HOME%/jre/lib/ext</strong>下的jar包，用户可以把自己开发的类打成包放进去，以<strong>扩展Java核心类以外</strong>的新功能。扩展类加载器派生继承自java.lang.ClassLoader，其父加载器（注意不是父类！）是启动类加载器。</p><h4 id="3-系统类加载器（System-ClassLoader）"><a href="#3-系统类加载器（System-ClassLoader）" class="headerlink" title="3.系统类加载器（System ClassLoader）"></a>3.系统类加载器（System ClassLoader）</h4><p>也叫应用程序类加载器，加载<strong>CLASSPATH环境变量</strong>指定的目录下的类，一般来说就是用户在应用程序中自定义的类、以及依赖的第三方jar包等。系统类加载器派生继承自java.lang.ClassLoader，其父加载器（注意不是父类！）是扩展类加载器。</p><h4 id="4-自定义类加载器"><a href="#4-自定义类加载器" class="headerlink" title="4.自定义类加载器"></a>4.自定义类加载器</h4><p>一般情况下，以上3种加载器能满足我们日常的开发工作，不满足时我们还可以自定义类加载器。比如用网络加载Java类，为了保证传输中的安全性，采用了加密操作，那么以上3种加载器就无法加载这个类，这时候就需要自定义类加载器。实现方法是<strong>继承java.lang.ClassLoader类</strong>，<strong>重写findClass()方法</strong>。</p><p><strong><em>类加载的双亲委派机制：</em></strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogbi1vlllj30x80r41kx.jpg" alt></p><ul><li>如果一个类加载器接收到了类加载的请求，它自己不会先去加载，会把这个请求委托给父类加载器去执行。</li><li>如果父类还存在父类加载器，则继续向上委托，一直委托到启动类加载器。</li><li>如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载。</li></ul><p><strong>源码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">// 递归思想</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// parent是null，说明已经递归到扩展类加载器了（因为扩展类加载器的parent是启动类加载器，而启动类加载器不是Java实现的，因此获取结果是null）</span></span><br><span class="line">            c = findBootstrapClassOrNull(name); <span class="comment">// 因为无法通过parent取到启动类加载器，直接需要直接调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found from the non-null parent class loader父加载器找不到该类就抛异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = findClass(name); <span class="comment">// 父加载器找不到，那就自己找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="/2021/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/03/09/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>类加载的定义：</strong>Java代码经过<strong>编译</strong>，会生成JVM能够识别的<strong>二进制字节流文件(*.class)</strong>。在Java程序的<strong>运行时</strong>，JVM把描述类的数据从<strong>Class文件</strong>加载到<strong>内存</strong>，并对数据进行校检、转换解析和初始化，最终形成可以被虚拟机直接使用的<strong>Java类型</strong>，这就是<strong>虚拟机的类加载机制</strong>。</p></blockquote><a id="more"></a><p>Class文件中的类，从加载到JVM内存，到卸载出内存，共有<strong>七个生命周期阶段</strong>，分别是<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>、<strong>使用</strong>、<strong>卸载</strong>。<strong>类加载机制</strong>包含了<strong>前五个阶段</strong>：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goevq4xr7tj30z20cgwrk.jpg" alt></p><p><strong>初始化</strong>和<strong>解析</strong>发生的<strong>先后顺序并不确定</strong>，解析可能发生在初始化之前，也可以发生在初始化之后（为了支持Java的<strong>动态绑定</strong>机制，由于Java多态，暂时不知道到底哪段代码会被调用，所以解析阶段可能会延后）。</p><blockquote><p><strong>类加载的时机：</strong>类加载无需等到程序中“首次被使用”时才开始，JVM预先加载某些类也是允许的。</p></blockquote><p>类加载的<strong>五个阶段</strong>可以总结为<strong>三步</strong>：<strong>加载</strong>、<strong>链接</strong>、<strong>初始化</strong>。</p><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><p>主要完成三件事：</p><ul><li>通过一个类的<strong>全限定名（包名+类名）</strong>来获取定义此类的二进制字节流（Class文件）。</li><li>将这个字节流代表的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong>。（方法区就是用来存放已被加载的类信息、常量、静态变量的运行时内存区域）</li><li>在内存中生成一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区<strong>这个类的各种数据的访问入口</strong>。</li></ul><p>总的来说，<strong>加载</strong>过程就是将一个类的二进制字节流<strong>Class文件</strong>转化成对应的<strong>java.lang.Class对象</strong>的过程。</p><h4 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h4><p>类加载后生成了java.lang.Class对象，接着会进入链接阶段，将类的二进制数据合并入JRE（Java运行时环境）中，链接包含三个阶段：</p><ul><li><strong>验证：</strong>验证被加载的类是否有正确的结构，类数据是否会符合虚拟机的要求，确保不会危害虚拟机的安全。</li><li><strong>准备：</strong>为类的<strong>静态变量（static）</strong>在<strong>方法区</strong>分配内存，并赋<strong>默认初值</strong>（0或者null）。注意如果是<strong>静态常量（static final）</strong>，早在<strong>编译期</strong>就已经存放在<strong>常量池</strong>中了，而现在<strong>再次在方法区里分配内存</strong>，并直接赋<strong>设定初值</strong>，而非默认初值。如果是<strong>普通成员成员变量</strong>，则要等到<strong>实例化</strong>的时候才会在<strong>堆中</strong>分配内存。</li><li><strong>解析：</strong>将<strong>Class文件常量池</strong>（不是运行时常量池）内的符号引用替换为<strong>直接引用</strong>。（静态绑定和动态绑定就在这时进行）直接引用可以是<strong>直接指向目标的指针</strong>、<strong>相对偏移量</strong>或是<strong>一个能直接定位到目标的句柄</strong>。如果有了直接引用，那么引用的目标必定<strong>已经在内存中存在</strong>。</li></ul><h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>类的初始化是类加载机制的最后一步，到了初始化阶段才真正执行Java代码。主要工作是为<strong>静态变量（static，但不包括static final）</strong>赋<strong>设定初值</strong>。</p><p>JVM规范中<strong>有且仅有五种情况必须对类进行初始化</strong>（<strong>类加载机制</strong>的前几个阶段自然而然也要在初始化之前进行）：</p><ul><li><p>使用<strong>new字节码指令创建类的实例</strong>，或者使用getstatic、putstatic<strong>读取或设置一个静态字段的值（在编译期就已经放入常量池中的static final常量除外）</strong>，或者<strong>调用一个静态方法</strong>的时候，对应类必须进行过初始化。</p></li><li><p>通过java.lang.reflect包的方法对类进行<strong>反射调用</strong>的时候，如果类没有进行过初始化，则要首先进行初始化。</p></li><li><p>当初始化一个类的时候，如果发现其父类没有进行过初始化，则<strong>首先触发父类初始化</strong>。</p></li><li><p>当<strong>虚拟机启动时</strong>，用户需要指定一个<strong>主类</strong>（包含main()方法的类），虚拟机会首先初始化这个类。</p></li><li><p>使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。</p></li></ul><p>上面这五种情况被称为<strong>主动引用</strong>，除了这五种情况，其他所有的类引用方式都<strong>不会触发类的初始化</strong>，被称为<strong>被动引用（三种）</strong>：</p><ul><li>通过子类引用父类的静态字段，对于父类属于“主动引用”的第三种情况，父类会被初始化；而对于子类属于“被动引用”，故子类不会初始化。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态变量value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">666</span>;</span><br><span class="line"><span class="comment">//静态块，父类初始化时会调用</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类初始化！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line"><span class="comment">//静态块，子类初始化时会调用</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子类初始化！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主类、测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(SubClass.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过数组来引用类，因为是new数组而不是new类的实例，因此属于被动引用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态变量value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">666</span>;</span><br><span class="line"><span class="comment">//静态块，父类初始化时会调用</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类初始化！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主类、测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">SuperClass[] test = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读取类的静态常量（static final），因为已经在编译时就存在常量池了，可以直接从常量池中读，因此不会触发类的初始化，属于被动引用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"常量类初始化！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主类、测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInit</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体架构与微服务架构</title>
      <link href="/2021/03/09/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
      <url>/2021/03/09/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单体架构与微服务架构的比较，以及服务拆分的原则。</p></blockquote><a id="more"></a><p>首先，<strong>单体架构不一定比微服务架构更好</strong>，各自有其适用的场景。</p><p>单体架构适合<strong>用户量少、业务简单</strong>的初创项目，可以<strong>小成本快速试错</strong>。且由于系统模块之间的调用是<strong>进程内通信</strong>，系统整体<strong>性能表现更好</strong>。</p><p>系统经过一段时间的运营后，随着用户量扩大，业务类型扩展，整个系统的<strong>业务量会变的复杂而庞大</strong>。这时系统的启动时间、重新编译时间都会非常<strong>耗时</strong>，且系统某个位置出现异常可能会导致整个系统崩溃，所谓<strong>牵一发而动全身</strong>。对一个功能的修复也需要做全盘的回归测试，并且要<strong>重新部署整个应用</strong>，使得系统的变更非常不灵活。这时候更适合使用微服务架构，将单体系统拆分为多个服务子系统，每个子系统可以<strong>独立地开发、升级维护和部署</strong>，各子系统结合业务及团队特点<strong>选择适合的技术栈</strong>，灵活性更高。但是系统模块间通信，从进程内通信变成进程间通信，所以系统<strong>响应速度会受到影响</strong>。</p><p>服务拆分的原则：一般按照<strong>业务边界</strong>来拆分。比如订单管理服务、日志管理服务、商品管理服务等。</p>]]></content>
      
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>424.替换后的最长重复字符</title>
      <link href="/2021/02/03/%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
      <url>/2021/02/03/%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>424.替换后的最长重复字符</p></blockquote><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>注意：</strong>字符串长度 和 k 不会超过 104。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：s = “ABAB”, k = 2<br>输出：4<br>解释：用两个’A’替换为两个’B’,反之亦然。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：s = “AABABBA”, k = 1<br>输出：4<br>解释：<br>将中间的一个’A’替换为’B’,字符串变为 “AABBBBA”。<br>子串 “BBBB” 有最长重复字母, 答案为 4。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，遇到这种<strong>类似于“求最长子字符串”</strong>的问题，就隐隐约约的感觉到<strong>滑动窗口（双指针）</strong>的影子了。</p><p>确实是使用双指针。两个指针均从字符串左端出发，每个迭代右指针右移一位，如果依然满足<strong>right - left + 1 &lt;= k + maxCount</strong>，maxCount是字符的最大重复次数，则说明k还够用，左指针不动；如果不满足上式，说明k不够用了，左指针右移一位，从而<strong>维护好满足条件的最大区间长度</strong>。双指针移动的过程中区间长度绝不会变短。<strong>右指针是主动轮，左指针是从动轮</strong>（和二维迭代的本质区别，后者两个指针都是主动轮，从前往后遍历）。</p><p>在两个指针移动的过程中，维护好一个<strong>26个字母的数组</strong>，记录每个字母在当前区间中的出现次数，其中的最大值即为<strong>maxCount</strong>。</p><p>因为双指针都是从前往后遍历一次，因此时间复杂度为<strong>O(n)</strong>，n是字符串长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>复习双指针的写法（while判断条件）～</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// 记录26个字母在滑动窗口中重复出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 滑动窗口左指针（从动轮）</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>; <span class="comment">// 滑动窗口右指针（主动轮），滑动窗口是闭区间</span></span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>; <span class="comment">// 重复出现次数最大的字母的重复出现次数</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            table[s.charAt(right) - <span class="string">'A'</span>]++; <span class="comment">// 右指针的字母出现次数自增一次</span></span><br><span class="line">            maxCount = Math.max(maxCount, table[s.charAt(right) - <span class="string">'A'</span>]); <span class="comment">// 最大重复次数只有可能是右指针上的新字母来挑战</span></span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; k + maxCount) &#123; <span class="comment">// k不够用了</span></span><br><span class="line">                table[s.charAt(left) - <span class="string">'A'</span>]--; <span class="comment">// 左指针的字母出现次数自减一次</span></span><br><span class="line">                left++; <span class="comment">// 左指针右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">// 右指针右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left; <span class="comment">// 闭区间长度没有+1，因为跳出while循环之前right多增了一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>888.公平的糖果棒交换</title>
      <link href="/2021/02/02/%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2/"/>
      <url>/2021/02/02/%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>888.公平的糖果交换</p></blockquote><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。</p><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</p><p>返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。</p><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：A = [1,1], B = [2,2]<br>输出：[1,2]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：A = [1,2], B = [2,3]<br>输出：[1,2]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：A = [2], B = [1,3]<br>输出：[2,3]</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：A = [1,2,5], B = [2,4]<br>输出：[5,4]</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>1 &lt;= B.length &lt;= 10000</li><li>1 &lt;= A[i] &lt;= 100000</li><li>1 &lt;= B[i] &lt;= 100000</li><li>保证爱丽丝与鲍勃的糖果总量不同。</li><li>答案肯定存在。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一上来就有了大体的思路：A和B交换的数字的差值，应该是A的总数与B的总数的差值的二分之一，即<strong>a - b = (sumA - sumB) / 2</strong>。那么就遍历A中的每个数，同时遍历B中的每个数，看是否存在满足上式的数字就行。</p><p>上面的方法，对遍历的每个a，都要同时遍历所有b，因此复杂度是<strong>O(mn)</strong>，m和n分别是数组A和B的长度。</p><p>可以利用<strong>哈希表</strong>的数据结构将复杂度降到<strong>线性</strong>：</p><p><strong>将数组B存到哈希表中</strong>，这样对于遍历到的每个数字a，只需要在哈希表中查询是否存在符合条件的b即可。</p><p>采用了哈希表后，只需要遍历一次数组A，且<strong>哈希表的查询时间复杂度是常数级别的</strong>，因此总的时间复杂度降到了<strong>O(m+n)</strong>！</p><p>启发：<strong>将数组转换成哈希表</strong>，巧妙地利用<strong>哈希表</strong>的<strong>常数时间查询</strong>替代<strong>线性遍历</strong>去优化时间复杂度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java中实现哈希表的集合类是<strong>HashSet</strong>哦～</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] fairCandySwap(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">        <span class="keyword">int</span> sumA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            sumA += a;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; bSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;(); <span class="comment">// 将数组B存成哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : B) &#123;</span><br><span class="line">            sumB += b;</span><br><span class="line">            bSet.add(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">int</span> bExpect = a - (sumA - sumB)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (bSet.contains(bExpect)) &#123; <span class="comment">// 哈希表查询</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, bExpect&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>839.相似字符串组</title>
      <link href="/2021/02/01/%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/"/>
      <url>/2021/02/01/%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>839.相似字符串组</p></blockquote><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><p>例如，”tars” 和 “rats” 是相似的 (交换 0 与 2 的位置)； “rats” 和 “arts” 也是相似的，但是 “star” 不与 “tars”，”rats”，或 “arts” 相似。</p><p>总之，它们通过相似性形成了两个关联组：{“tars”, “rats”, “arts”} 和 {“star”}。注意，”tars” 和 “arts” 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？</p><p><strong>示例 1：</strong></p><blockquote><p>输入：strs = [“tars”,”rats”,”arts”,”star”]<br>输出：2</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：strs = [“omv”,”ovm”]<br>输出：1</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= strs.length &lt;= 100</li><li>1 &lt;= strs[i].length &lt;= 1000</li><li>sum(strs[i].length) &lt;= 2 * 104</li><li>strs[i] 只包含小写字母。</li><li>strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li></ul><p><strong>备注：</strong></p><p>​        字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先贴一下知乎大佬对<a href="https://zhuanlan.zhihu.com/p/93647900/" target="_blank" rel="noopener">并查集</a>的详细解读。</p><p>只要A和B相似，B和C相似，即使A和C不相似，ABC也是一组。映射到图论中，就是妥妥的<strong>求联通集数目</strong>的问题，<strong>不多BB直接上并查集</strong>。</p><ul><li>首先解决下如何判断两个字符串相似的问题。很简单，相似的两个字符串，只有<strong>两个位置</strong>上的字符不一样，其他位置都是一样的，问题解决。</li><li>然后解决求联通集数目的问题。所有的字符串<strong>两两比较</strong>，如果同属于一个联通集（<strong>根节点相同</strong>），直接不用比了；如果两个字符串不属于同一个联通集且相似，那么合并这两个联通集（<strong>一个联通集的根节点认另一个联通集的根节点做爹</strong>）。最后统计联通集的总数（<strong>统计根节点的数目</strong>），问题解决。</li></ul><p>解决第一个问题，为了比较两个字符串是否相似，需要O(m)的时间，m是每个字符串的长度；那么两两比较需要O(mn^2)的时间，n是字符串的总数；解决第二个问题，最坏情况下需要对并查集进行O(n)次合并，合并的均摊时间复杂度为O(logn)，logn也就是节点数为n的树的高度（相当于找到根节点的时间）。总的时间复杂度是<strong>O(mn^2 + nlogn)</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] f; <span class="comment">// 并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 初始化并查集 */</span></span><br><span class="line">        f = <span class="keyword">new</span> <span class="keyword">int</span>[strs.length]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i) &#123;</span><br><span class="line">            f[i] = i; <span class="comment">// 初始时，每个节点的父节点都是自己，单独作为一个联通集</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 所有字符串两两比较一遍 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; strs.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (find(i) == find(j)) &#123; <span class="comment">// 两个节点的根节点一样，说明是同一个联通集的</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (check(strs[i], strs[j], strs[<span class="number">0</span>].length())) &#123; <span class="comment">// 两个节点不属于同一个联通集但是经判断后是相似的</span></span><br><span class="line">                    f[find(i)] = find(j); <span class="comment">// 合并两个节点各自所属的联通集，即一个联通集的根节点认另一个联通集的根节点做爹</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 查找根节点的数量，即联通集的总数 */</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] == i) &#123; <span class="comment">// 父节点是自己，即为根节点</span></span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找节点的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : (f[x] = find(f[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个字符串是否相似</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String str1, String str2, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123; <span class="comment">// 相似的字符串最多只有两个字符不一样</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>778.水位上升的泳池中游泳</title>
      <link href="/2021/01/31/%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/"/>
      <url>/2021/01/31/%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>778.水位上升的泳池中游泳</p></blockquote><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i] [j] 表示在位置 (i,j) 的平台高度。</p><p>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p><p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [[0,2],[1,3]]<br><strong>输出:</strong> 3<br><strong>解释:</strong><br>时间为0时，你位于坐标方格的位置为 (0, 0)。<br>此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。</p><p>等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入:</strong> [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br><strong>输出:</strong> 16<br><strong>解释:</strong><br> <strong>0  1  2  3  4</strong><br>24 23 22 21  <strong>5</strong><br><strong>12 13 14 15 16</strong><br><strong>11</strong> 17 18 19 20<br><strong>10  9  8  7  6</strong></p><p>最终的路线用加粗进行了标记。<br>我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的</p></blockquote><p><strong>提示:</strong></p><ul><li>2 &lt;= N &lt;= 50.</li><li>grid[i] [j] 是 [0, …, N*N - 1] 的排列。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本体的思想和<a href="https://loumoon.github.io/2021/01/30/最小体力消耗路径/"><strong>1631.最小体力消耗路径</strong></a>如出一辙。</p><p><strong>首先我想到的是深度优先搜索</strong>/广度优先搜索找到水位高度最矮的路径。</p><p>但是，<strong>使用深度/广度优先搜索只能找到符合某个特定条件的路径，没有办法在搜索完毕后同时找到水位高度最矮的路径。</strong></p><p>因此可以考虑将复杂问题转化为简单问题，即<strong>将原问题转化为两个相对简单的问题</strong>：</p><ul><li><p>是否存在一条从左上角到右下角的路径，其经过的所有点的高度的最大值不超过 x？</p></li><li><p>这个x最小是几？</p></li></ul><p>显然对问题1只需要对节点图进行一次<strong>深度/广度优先搜索</strong>即可解答，复杂度为<strong>O(n*n)</strong>。</p><p>然后对问题2，我们可以在x的所有候选集的范围中去进行<strong>二分搜索</strong>，找到这个最小的x，复杂度为<strong>O(logn*n)</strong>。</p><p>总的复杂度是<strong>O(n^2logn)</strong>。</p><p>本题的<strong>核心思想</strong>是，<strong>将一个复杂问题转化为两个相对简单问题的集合</strong>。通过分别解决这两个相对简单的问题，最终解决困难问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面代码可以对<strong>二分查找</strong>和<strong>广度优先搜索</strong>的写法进行一个很好的复习。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;; <span class="comment">// 方向盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = grid.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = width * width - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 二分搜索</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; grid[<span class="number">0</span>][<span class="number">0</span>]) &#123; <span class="comment">// 至少水位要高于起点高度，不然寸步难行</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">int</span>[][] seen = <span class="keyword">new</span> <span class="keyword">int</span>[width][width];</span><br><span class="line">            <span class="keyword">int</span> exist = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">// 广度优先搜索</span></span><br><span class="line">                <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> x = point[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = point[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xnext = x + direction[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ynext = y + direction[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (xnext &gt;= <span class="number">0</span> &amp;&amp; xnext &lt; width</span><br><span class="line">                    &amp;&amp; ynext &gt;= <span class="number">0</span> &amp;&amp; ynext &lt; width</span><br><span class="line">                    &amp;&amp; grid[xnext][ynext] &lt;= mid</span><br><span class="line">                    &amp;&amp; seen[xnext][ynext] == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (xnext == (width - <span class="number">1</span>) &amp;&amp; ynext == (width - <span class="number">1</span>)) &#123;</span><br><span class="line">                            exist = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;xnext, ynext&#125;);</span><br><span class="line">                            seen[xnext][ynext] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exist == <span class="number">1</span>) &#123;</span><br><span class="line">                result = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1631.最小体力消耗路径</title>
      <link href="/2021/01/30/%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/01/30/%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1631.最小体力消耗路径</p></blockquote><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row] [col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。</p><p>一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。</p><p>请你返回从左上角走到右下角的最小 体力消耗值 。</p><p><strong>示例 1：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn64cifydjj30im0ii750.jpg" alt="image-20210130230403049"></p><blockquote><p>输入：heights = [[1,2,2],[3,8,2],[5,3,5]]<br>输出：2<br>解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。<br>这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn64cr5v32j30ig0iiq3n.jpg" alt="image-20210130230419400"></p><blockquote><p>输入：heights = [[1,2,3],[3,8,4],[5,3,5]]<br>输出：1<br>解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。</p></blockquote><p><strong>示例 3：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn64d1dlamj30iu0is3z5.jpg" alt="image-20210130230434943"></p><blockquote><p>输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]<br>输出：0<br>解释：上图所示路径不需要消耗任何体力。</p></blockquote><p><strong>提示：</strong></p><ul><li>rows == heights.length</li><li>columns == heights[i].length</li><li>1 &lt;= rows, columns &lt;= 100</li><li>1 &lt;= heights[i] [j]&lt;= 1000000</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我想到的是深度优先搜索/广度优先搜索，找到最小体力消耗路径。</p><p>但是，<strong>使用深度/广度优先搜索只能找到符合某个特定条件的路径，没有办法在搜索完毕后同时找到最小路径。</strong></p><p>因此可以考虑将复杂问题转化为简单问题，即<strong>将原问题转化为两个相对简单的问题</strong>：</p><ul><li>是否存在一条从左上角到右下角的路径，其经过的所有边权（节点间高度差）的最大值不超过 x？</li><li>这个x最小是几？</li></ul><p>显然对问题1只需要对节点图进行一次<strong>深度/广度优先搜索</strong>即可解答，复杂度为<strong>O(mn)</strong>。</p><p>然后对问题2，我们可以在x的所有候选集的范围中去进行<strong>二分搜索</strong>，找到这个最小的x，复杂度为<strong>O(logC)</strong>，C是最大高度差999999。</p><p>总的复杂度是<strong>O(mnlogC)</strong>。</p><p>本题的<strong>核心思想</strong>是，<strong>将一个复杂问题转化为两个相对简单问题的集合</strong>。通过分别解决这两个相对简单的问题，最终解决困难问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面代码可以对<strong>二分查找</strong>和<strong>广度优先搜索</strong>的写法进行一个很好的复习。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 方向盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = heights.length;</span><br><span class="line">        <span class="keyword">int</span> columns = heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span>[][] seen = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">            Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> exist = <span class="number">0</span>;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">// 广度优先搜索</span></span><br><span class="line">                <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> x = point[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = point[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : direction) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xnext = x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ynext = y + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (xnext &gt;= <span class="number">0</span> &amp;&amp; xnext &lt; rows </span><br><span class="line">                    &amp;&amp; ynext &gt;= <span class="number">0</span> &amp;&amp; ynext &lt; columns </span><br><span class="line">                    &amp;&amp; seen[xnext][ynext] == <span class="number">0</span></span><br><span class="line">                    &amp;&amp; Math.abs(heights[xnext][ynext] - heights[x][y]) &lt;= mid) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (xnext == (rows - <span class="number">1</span>) &amp;&amp; ynext == (columns - <span class="number">1</span>))&#123;</span><br><span class="line">                            exist = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;xnext, ynext&#125;);</span><br><span class="line">                        seen[xnext][ynext] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exist == <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>724.寻找数组的中心索引</title>
      <link href="/2021/01/29/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
      <url>/2021/01/29/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>724.寻找数组的中心索引</p></blockquote><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p><p>数组 中心索引 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，返回 -1 。如果数组有多个中心索引，应该返回最靠近左边的那一个。</p><p><strong>注意：</strong>中心索引可能出现在数组的两端。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。<br>同时, 3 也是第一个符合要求的中心索引。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [1, 2, 3]<br>输出：-1<br>解释：<br>数组中不存在满足此条件的中心索引。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [2, 1, -1]<br>输出：0<br>解释：<br>索引 0 左侧不存在元素，视作和为 0 ；右侧数之和为 1 + (-1) = 0 ，二者相等。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：nums = [0, 0, 0, 0, 1]<br>输出：4<br>解释：<br>索引 4 左侧数之和为 0 ；右侧不存在元素，视作和为 0 ，二者相等。</p></blockquote><p><strong>提示：</strong></p><ul><li>nums 的长度范围为 [0, 10000]。</li><li>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先思路肯定是遍历数组，找到符合条件的中间索引。</p><p>不动脑筋地想一下，每遍历到一个数，都要累加其左边的所有数，再累加其后边的所有数，然后比较是否相等。这样的时间复杂度是n方，肯定是超时的。</p><p>上面方法的核心问题在于，在累加时做了很多<strong>冗余的计算</strong>。</p><p>基于以上方法的改进思路：首先数组的总和是确定的，那么累加了左边所有数，直接有：<strong>总和-左边和-当前数=右边和</strong>，这样就省去了累加右边和的计算；其次每次迭代到一个数，不需要逐个累加左边数，因为迭代是从左到右顺序进行的，只需要用<strong>上个迭代的左边和</strong>，加上<strong>上个迭代的数</strong>，就是<strong>这个迭代的左边和</strong>，因此每个迭代只需要<strong>加一次</strong>就行了。最终改进后的时间复杂度是<strong>线性的</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">2</span>*left + nums[i]) == sum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = left + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Jackson库实现日期序列化</title>
      <link href="/2020/09/19/%E4%BD%BF%E7%94%A8Jackson%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%97%A5%E6%9C%9F%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/09/19/%E4%BD%BF%E7%94%A8Jackson%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%97%A5%E6%9C%9F%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Jackson是一个Java的用来处理JSON格式数据的类库，性能非常好。在项目开发中，使用Jackson库的@JsonSerialize注解实现日期的自定义格式的序列化，这里做一个记录。</p></blockquote><a id="more"></a><h2 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h2><p>对于一个Model层对象的Date字段，在序列化为JSON数据时，可以使用Jakson库的@JsonFormat注解来定义格式，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>,timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date testTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目的实际开发过程中，这个日期可能不是Date，而是其他格式，比如Instant，此时再使用@JsonFormat注解就会报错。此时可以通过<strong>继承StdSerializer抽象类</strong>和<strong>@JsonSerialize注解</strong>来实现自定义格式的序列化。</p><h2 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h2><h3 id="1-Instant序列化类InstantSerializer-java"><a href="#1-Instant序列化类InstantSerializer-java" class="headerlink" title="1. Instant序列化类InstantSerializer.java"></a>1. Instant序列化类InstantSerializer.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantSerializer</span> <span class="keyword">extends</span> <span class="title">StdSerializer</span>&lt;<span class="title">Instant</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstantSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstantSerializer</span><span class="params">(Class&lt;Instant&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Instant instant, JsonGenerator jsonGenerator, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instant == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String jsonValue = format.format(instant.atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>)));</span><br><span class="line">        jsonGenerator.writeString(jsonValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InstantSerializer继承了StdSerializer抽象类，将Instant序列化为”yyyy-MM-dd HH:mm:ss”的日期格式。</p><h3 id="2-String序列化类UTCDaySerializer-java"><a href="#2-String序列化类UTCDaySerializer-java" class="headerlink" title="2. String序列化类UTCDaySerializer.java"></a>2. String序列化类UTCDaySerializer.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UTCDaySerializer</span> <span class="keyword">extends</span> <span class="title">StdSerializer</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UTCDaySerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UTCDaySerializer</span><span class="params">(Class&lt;String&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(String timeString, JsonGenerator jsonGenerator, SerializerProvider provider)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeString == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = timeString.indexOf(<span class="string">"T"</span>);</span><br><span class="line">        String jsonValue = timeString.substring(<span class="number">0</span>, index); <span class="comment">// yyyy-MM-dd</span></span><br><span class="line">        jsonGenerator.writeString(jsonValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UTCDaySerializer也继承了StdSerializer抽象类，将UTC格式的String日期，即”yyyy-MM-dd’T’HH:mm:ss’Z’”截取前半段，即”yyyy-MM-dd”的日期格式。</p><h3 id="3-LogStatusDTO-java"><a href="#3-LogStatusDTO-java" class="headerlink" title="3. LogStatusDTO.java"></a>3. LogStatusDTO.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogStatusDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = InstantSerializer.class)</span><br><span class="line">    <span class="keyword">private</span> Instant timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@JsonSerialize注解和InstantSerializer来序列化Instant类型的timestamp字段。</p><h3 id="4-ServiceLogNumPerDayDTO-java"><a href="#4-ServiceLogNumPerDayDTO-java" class="headerlink" title="4. ServiceLogNumPerDayDTO.java"></a>4. ServiceLogNumPerDayDTO.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Measurement</span>(name = <span class="string">"log"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLogNumPerDayDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"time"</span>)</span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = UTCDaySerializer.class)</span><br><span class="line">    String date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"count_content"</span>)</span><br><span class="line">    Integer count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@JsonSerialize注解和UTCDaySerializer来序列化String类型的date字段。</p>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jackson </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Jackson库实现Java多态解析</title>
      <link href="/2020/09/19/%E4%BD%BF%E7%94%A8Jackson%E5%BA%93%E5%AE%9E%E7%8E%B0Java%E5%A4%9A%E6%80%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/09/19/%E4%BD%BF%E7%94%A8Jackson%E5%BA%93%E5%AE%9E%E7%8E%B0Java%E5%A4%9A%E6%80%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Jackson是一个Java的用来处理JSON格式数据的类库，性能非常好。在项目开发中，使用Jackson库的@JsonTypeInfo和@JsonSubTypes注解实现Java多态解析，这里做一个记录。</p></blockquote><a id="more"></a><h2 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h2><p>在项目开发中，model层的Channel类是一个多态的实现，Channel是一个抽象基类，其有两个子类DatasourceChannel和ServiceChannel。底层的数据库采用MongoDB，因此Channel的所有对象都是在一张表（collection）上的。这样的设计（多态思想）非常优雅，因为只需要面向接口（抽象类）编程而非面向实现（子类）编程。</p><ul><li><strong>序列化</strong>：Java对象转化为JSON格式数据（而后持久化在数据库中）</li><li><strong>反序列化</strong>：通过JSON格式数据创建对应的Java对象</li></ul><p>在默认的情况下，Java对象和序列化后的JSON格式数据的属性都是一样的。但是在Channel的多态实现下，需要具体的<strong>类型信息</strong>（子类）指导<strong>反序列化</strong>（因为两个子类的属性集是不同的）。通过Jackson库的@JsonTypeInfo与@JsonSubTypes注解，可以在序列化时，保存具体的类型信息到JSON数据中，当JSON反序列到Java对象时，就可以根据具体类型信息创建正确的Java对象。</p><ul><li><strong>@JsonTypeInfo</strong>：指明类型信息字段</li><li><strong>@JsonSubTypes</strong>：指明不同类型信息分别对应的子类</li></ul><h2 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h2><h3 id="1-抽象基类Channel-java"><a href="#1-抽象基类Channel-java" class="headerlink" title="1. 抽象基类Channel.java"></a>1. 抽象基类Channel.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"channel"</span>)</span><br><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = <span class="string">"type"</span>)</span><br><span class="line"><span class="meta">@JsonSubTypes</span>(&#123;</span><br><span class="line">        <span class="meta">@JsonSubTypes</span>.Type(value = ServiceChannel.class, name = <span class="string">"Service"</span>),</span><br><span class="line">        <span class="meta">@JsonSubTypes</span>.Type(value = DatasourceChannel.class, name = <span class="string">"DataSource"</span>),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">protected</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">protected</span> String ownerId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;TransformRule&gt; transformRules;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> FusionRule fusionRule;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> ChannelDTO <span class="title">convert2DTO</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doDataDistribution</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doCompletion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@JsonTypeInfo指明了类型信息字段为type，@JsonSubTypes指明子类ServiceChannel的类型信息为“Service”，子类DatasourceChannel的类型信息为“DataSource”。</p><p>类型信息字段type不属于Channel对象中的属性，它只存在于序列化后的JSON数据中。举个例子，一个普通的ServiceChannel对象序列化为JSON数据时，在JSON数据中会多出一个type属性：*”type” : “Service”*。如果从数据库中拿出这条JSON数据，反序列化为Java对象时，会遵循这个type字段的指导，按照子类ServiceChannel的属性集去构造对应的ServiceChannel对象，而构造成功的ServiceChannel对象中，不会出现该type字段。</p><h3 id="2-子类DatasourceChannel-java"><a href="#2-子类DatasourceChannel-java" class="headerlink" title="2. 子类DatasourceChannel.java"></a>2. 子类DatasourceChannel.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String datasourceId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatasourceChannel</span><span class="params">(String id, String ownerId, List&lt;TransformRule&gt; transformRules, FusionRule fusionRule, String description, String datasourceId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.id = id;</span><br><span class="line">        <span class="keyword">super</span>.ownerId = ownerId;</span><br><span class="line">        <span class="keyword">this</span>.transformRules = transformRules;</span><br><span class="line">        <span class="keyword">this</span>.fusionRule = fusionRule;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">        <span class="keyword">this</span>.datasourceId = datasourceId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-子类ServiceChannel-java"><a href="#3-子类ServiceChannel-java" class="headerlink" title="3. 子类ServiceChannel.java"></a>3. 子类ServiceChannel.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String serviceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String apiId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String apiPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpMethod apiMethod;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String datasourceId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String processId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceChannel</span><span class="params">(String id, String ownerId, String serviceId, String apiId, List&lt;TransformRule&gt; transformRules, FusionRule fusionRule, String description, String processId, String datasourceId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.id = id;</span><br><span class="line">        <span class="keyword">super</span>.ownerId = ownerId;</span><br><span class="line">        <span class="keyword">this</span>.serviceId = serviceId;</span><br><span class="line">        <span class="keyword">this</span>.apiId = apiId;</span><br><span class="line">        <span class="keyword">this</span>.transformRules = transformRules;</span><br><span class="line">        <span class="keyword">this</span>.fusionRule = fusionRule;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">        <span class="keyword">this</span>.processId = processId;</span><br><span class="line">        <span class="keyword">this</span>.datasourceId = datasourceId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jackson </tag>
            
            <tag> JSON </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot+InfluxDB实现日志管理</title>
      <link href="/2020/08/07/SpringBoot+InfluxDB%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
      <url>/2020/08/07/SpringBoot+InfluxDB%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在实验室航天微服务项目的开发中，需要引入时序数据库进行日志数据的存取，经过事先的<a href="https://loumoon.github.io/2020/05/12/时序数据库调研/">时序数据库调研</a>最终选择采用InfluxDB。本文记录一下使用Spring Boot+InfluxDB实现日志管理的具体细节。</p></blockquote><a id="more"></a><h2 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h2><p>在考虑引入InfluxDB之前，整个项目都使用MongoDB进行数据存储，但是考虑到日志数据相对于业务数据的特点，最终选择了更适合的InfluxDB用来专门存放日志数据。项目是基于微服务和Spring Boot框架构建的，由于在Spring Boot的框架中，InfluxDB不存在类似MongoDB的spring-boot-starter-data-mongodb库，因此不能很方便地对Spring Boot自动配置数据库，也没有像MongoDB那样很方便的接口（比如MongoRepository等）可用。既然指望不上Spring Boot框架，我采用的是InfluxDB的Java客户端库<a href="https://github.com/influxdata/influxdb-java" target="_blank" rel="noopener">influxdb-java</a>。</p><h2 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h2><h3 id="1-InfluxDBUtil-java"><a href="#1-InfluxDBUtil-java" class="headerlink" title="1. InfluxDBUtil.java"></a>1. InfluxDBUtil.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfluxDBUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String database;</span><br><span class="line">    <span class="keyword">private</span> InfluxDB influxDB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfluxDBUtil</span><span class="params">(String url, String database)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">        <span class="keyword">this</span>.influxDB = buildInfluxDB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> InfluxDB <span class="title">buildInfluxDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (influxDB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            influxDB = InfluxDBFactory.connect(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!influxDB.databaseExists(database)) &#123;</span><br><span class="line">                influxDB.createDatabase(database);</span><br><span class="line">            &#125;</span><br><span class="line">            influxDB.setDatabase(database);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"create influx db failed, error: &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        influxDB.setLogLevel(InfluxDB.LogLevel.BASIC);</span><br><span class="line">        <span class="keyword">return</span> influxDB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryResult <span class="title">query</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> influxDB.query(<span class="keyword">new</span> Query(command, database));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String measurement, Map&lt;String, String&gt; tags, Map&lt;String, Object&gt; fields)</span> </span>&#123;</span><br><span class="line">        Point point = Point.measurement(measurement)</span><br><span class="line">                .time(System.currentTimeMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">                .tag(tags)</span><br><span class="line">                .fields(fields)</span><br><span class="line">                .build();</span><br><span class="line">        influxDB.write(point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个工具类，提供InfluxDB实例的创建以及插入和查询接口。</p><h3 id="2-InfluxDBConfig-java"><a href="#2-InfluxDBConfig-java" class="headerlink" title="2. InfluxDBConfig.java"></a>2. InfluxDBConfig.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfluxDBConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.influx.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.influx.database&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String database;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InfluxDBUtil <span class="title">influxDBUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InfluxDBUtil(url, database);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InfluxDBUtil的配置类，配置一颗InfluxDBUtil的实例bean（单例）。在Spring框架中@Bean是一个方法级别的注解，会生成一个Spring管理的bean实例，该bean实例的id为方法名。上面代码中的配置就相当于以下的xml配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"influxDBUtil"</span> <span class="attr">class</span>=<span class="string">"cn.ist.msplatform.logservice.util.InfluxDBUtil"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-Log-java"><a href="#3-Log-java" class="headerlink" title="3. Log.java"></a>3. Log.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Measurement</span>(name = <span class="string">"log"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"time"</span>)</span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = InstantSerializer.class)</span><br><span class="line">    <span class="keyword">private</span> Instant time;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"content"</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"datasourceName"</span>)</span><br><span class="line">    <span class="keyword">private</span> String datasourceName;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"serviceName"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"apiPath"</span>)</span><br><span class="line">    <span class="keyword">private</span> String apiPath;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"apiMethod"</span>)</span><br><span class="line">    <span class="keyword">private</span> String apiMethod;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"type"</span>, tag = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"processId"</span>, tag = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String processId;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"datasourceId"</span>, tag = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String datasourceId;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"serviceId"</span>, tag = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceId;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"apiId"</span>, tag = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String apiId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">tags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; tags = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        tags.put(<span class="string">"type"</span>, Optional.ofNullable(<span class="keyword">this</span>.getType()).orElse(<span class="string">""</span>));</span><br><span class="line">        tags.put(<span class="string">"processId"</span>, Optional.ofNullable(<span class="keyword">this</span>.getProcessId()).orElse(<span class="string">""</span>));</span><br><span class="line">        tags.put(<span class="string">"datasourceId"</span>, Optional.ofNullable(<span class="keyword">this</span>.getDatasourceId()).orElse(<span class="string">""</span>));</span><br><span class="line">        tags.put(<span class="string">"serviceId"</span>, Optional.ofNullable(<span class="keyword">this</span>.getServiceId()).orElse(<span class="string">""</span>));</span><br><span class="line">        tags.put(<span class="string">"apiId"</span>, Optional.ofNullable(<span class="keyword">this</span>.getApiId()).orElse(<span class="string">""</span>));</span><br><span class="line">        <span class="keyword">return</span> tags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">fields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; fields = <span class="keyword">new</span> HashMap&lt;&gt;( <span class="number">4</span>);</span><br><span class="line">        fields.put(<span class="string">"content"</span>, <span class="keyword">this</span>.content);</span><br><span class="line">        fields.put(<span class="string">"datasourceName"</span>, <span class="keyword">this</span>.datasourceName);</span><br><span class="line">        fields.put(<span class="string">"serviceName"</span>, <span class="keyword">this</span>.serviceName);</span><br><span class="line">        fields.put(<span class="string">"apiPath"</span>, <span class="keyword">this</span>.apiPath);</span><br><span class="line">        fields.put(<span class="string">"apiMethod"</span>, <span class="keyword">this</span>.apiMethod);</span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Model层，Log的所有属性从上到下分为time、fields、tags三类。</p><h3 id="4-LogRepository-java"><a href="#4-LogRepository-java" class="headerlink" title="4. LogRepository.java"></a>4. LogRepository.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogRepository</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InfluxDBUtil influxDBUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InfluxDBResultMapper resultMapper = <span class="keyword">new</span> InfluxDBResultMapper();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Log <span class="title">save</span><span class="params">(Log log)</span> </span>&#123;</span><br><span class="line">        influxDBUtil.insert(<span class="string">"log"</span>, log.tags(), log.fields());</span><br><span class="line">        <span class="keyword">return</span> log;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String command = <span class="string">"select * from log"</span>;</span><br><span class="line">        <span class="keyword">return</span> resultMapper.toPOJO(influxDBUtil.query(command), Log.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">findServiceLogLimit</span><span class="params">(String serviceId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;serviceId, num&#125;;</span><br><span class="line">        String command = String.format(<span class="string">"select * from log where serviceId='%s' and processId='' order by time desc limit %d"</span>, args);</span><br><span class="line">        <span class="keyword">return</span> resultMapper.toPOJO(influxDBUtil.query(command), Log.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">findServiceApiLogLimit</span><span class="params">(String serviceId, String apiId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;serviceId, apiId, num&#125;;</span><br><span class="line">        String command = String.format(<span class="string">"select * from log where serviceId='%s' and apiId='%s' and processId='' order by time desc limit %d"</span>, args);</span><br><span class="line">        <span class="keyword">return</span> resultMapper.toPOJO(influxDBUtil.query(command), Log.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">findDatasourceLogLimit</span><span class="params">(String datasourceId, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;datasourceId, num&#125;;</span><br><span class="line">        String command = String.format(<span class="string">"select * from log where datasourceId='%s' and processId='' order by time desc limit %d"</span>, args);</span><br><span class="line">        <span class="keyword">return</span> resultMapper.toPOJO(influxDBUtil.query(command), Log.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ServiceLogNumPerDayDTO&gt; <span class="title">findServiceLogNumPerDay</span><span class="params">(String start, String end, String serviceId)</span> </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;start, end, serviceId&#125;;</span><br><span class="line">        String command = String.format(<span class="string">"select count(*) from log where time &gt;= '%s' and time &lt; '%s' and serviceId = '%s' group by time(1d) tz('Asia/Shanghai')"</span>, args);</span><br><span class="line">        <span class="keyword">return</span> resultMapper.toPOJO(influxDBUtil.query(command), ServiceLogNumPerDayDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Repository层，代码第4行把InfluxDBConfig.java中配置的单例influxDBUtil注入进来（注意@Bean和@Service、@Controller等都是默认配置单例的，IOC容器检测到InfluxDBUtil.class就只有一个单例，因此就自动注入了进来）。从数据到实体的映射使用InfluxDBResultMapper接口实现。</p><h3 id="5-LogService-java"><a href="#5-LogService-java" class="headerlink" title="5. LogService.java"></a>5. LogService.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SendService sendService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogRepository logRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;detect.datasource.statusNum&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer datasourceStatusNum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;detect.service.statusNum&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer serviceStatusNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Log <span class="title">createLog</span><span class="params">(Log log)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.getProcessId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sendService.send(log);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> logRepository.save(log);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">createLogs</span><span class="params">(List&lt;Log&gt; logs)</span> </span>&#123;</span><br><span class="line">        List&lt;Log&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Log log : logs) &#123;</span><br><span class="line">            result.add(createLog(log));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> logRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">getRecentServiceLog</span><span class="params">(String serviceId, String apiId, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apiId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> logRepository.findServiceLogLimit(serviceId, num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> logRepository.findServiceApiLogLimit(serviceId, apiId, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Log&gt; <span class="title">getRecentDatasourceLog</span><span class="params">(String datasourceId, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> logRepository.findDatasourceLogLimit(datasourceId,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LogStatusDTO&gt; <span class="title">getDatasourceStatus</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        List&lt;Log&gt; recentLogs = logRepository.findDatasourceLogLimit(id,datasourceStatusNum);</span><br><span class="line"></span><br><span class="line">        List&lt;LogStatusDTO&gt; status = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Log recentLog : recentLogs) &#123;</span><br><span class="line">            status.add(LogStatusDTO.builder().timestamp(recentLog.getTime())</span><br><span class="line">                    .content(recentLog.getContent()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LogStatusDTO&gt; <span class="title">getServiceStatus</span><span class="params">(String serviceId, String apiId)</span> </span>&#123;</span><br><span class="line">        List&lt;Log&gt; recentLogs = logRepository.findServiceApiLogLimit(serviceId, apiId, serviceStatusNum);</span><br><span class="line"></span><br><span class="line">        List&lt;LogStatusDTO&gt; status = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Log recentLog : recentLogs) &#123;</span><br><span class="line">            status.add(LogStatusDTO.builder().timestamp(recentLog.getTime())</span><br><span class="line">                    .content(recentLog.getContent()).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ServiceLogNumPerDayDTO&gt; <span class="title">findServiceLogNumPerDay</span><span class="params">(String start, String end, String serviceId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> logRepository.findServiceLogNumPerDay(start, end, serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service层，没什么好说的。</p><h3 id="6-LogController-java"><a href="#6-LogController-java" class="headerlink" title="6. LogController.java"></a>6. LogController.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/log"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"创建日志"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Log&gt; <span class="title">createLog</span><span class="params">(@RequestBody Log log)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.createLog(log));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/logs"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"批量创建日志"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;Log&gt;&gt; createLogs(<span class="meta">@RequestBody</span> List&lt;Log&gt; logs) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.createLogs(logs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/log"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"查找所有日志"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;Log&gt;&gt; findAll() &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.findAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/log/recent/serviceLog"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"查找指定服务的最近若干条日志"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;Log&gt;&gt; findRecentServiceLog(<span class="meta">@RequestParam</span>(name = <span class="string">"serviceId"</span>) String serviceId,</span><br><span class="line">                                                  <span class="meta">@RequestParam</span>(name = <span class="string">"apiId"</span>,required=<span class="keyword">false</span>) String apiId,</span><br><span class="line">                                                  <span class="meta">@RequestParam</span>(name=<span class="string">"num"</span>,required = <span class="keyword">false</span>, defaultValue = <span class="string">"5"</span>) Integer num) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.getRecentServiceLog(serviceId, apiId, num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/log/recent/datasourceLog"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"查找指定数据源的最近若干条日志"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;Log&gt;&gt; findRecentDatasourceLog(<span class="meta">@RequestParam</span>(name = <span class="string">"datasourceId"</span>) String datasourceId,</span><br><span class="line">                                                     <span class="meta">@RequestParam</span>(name = <span class="string">"num"</span>,required = <span class="keyword">false</span>, defaultValue = <span class="string">"5"</span>) Integer num) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.getRecentDatasourceLog(datasourceId, num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/datasource/&#123;id&#125;/status"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"监控指定数据源的最近状态"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;LogStatusDTO&gt;&gt; getDatasourceStatus(<span class="meta">@PathVariable</span>(<span class="string">"id"</span>) String id) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.getDatasourceStatus(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/service/&#123;serviceId&#125;/&#123;apiId&#125;/status"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"监控指定服务的最近状态"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;LogStatusDTO&gt;&gt; getServiceStatus(<span class="meta">@PathVariable</span>(<span class="string">"serviceId"</span>) String serviceId,</span><br><span class="line">                                                       <span class="meta">@PathVariable</span>(<span class="string">"apiId"</span>) String apiId) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.getServiceStatus(serviceId,apiId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value=<span class="string">"/log/timestamp"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"在指定时间内，按每天特定服务的日志数量"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;ServiceLogNumPerDayDTO&gt;&gt; findServiceLogNumPerDay(<span class="meta">@RequestParam</span>(name = <span class="string">"start"</span>) Date start,</span><br><span class="line">                                                                        <span class="meta">@RequestParam</span>(name = <span class="string">"end"</span>) Date end,</span><br><span class="line">                                                                        <span class="meta">@RequestParam</span>(name = <span class="string">"serviceId"</span>) String serviceId)&#123;</span><br><span class="line">        Calendar calendar = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">        calendar.setTime(end);</span><br><span class="line">        calendar.add(Calendar.DATE, <span class="number">1</span>);</span><br><span class="line">        end = calendar.getTime();</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd'T'00:00:00+08:00"</span>);</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(logService.findServiceLogNumPerDay(sdf.format(start), sdf.format(end), serviceId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller层，没什么好说的。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> 时序数据库 </tag>
            
            <tag> InfluxDB </tag>
            
            <tag> 日志管理 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多态+工厂模式实现服务调用</title>
      <link href="/2020/08/05/Java%E5%A4%9A%E6%80%81+%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
      <url>/2020/08/05/Java%E5%A4%9A%E6%80%81+%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验室的项目开发中，一位大佬应用<strong>Java多态</strong>+<strong>工厂模式</strong>实现的服务调用，这里学习一下。</p></blockquote><a id="more"></a><h2 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h2><p>本项目是基于微服务开发的，用户可以在本平台上进行服务注册，注册在平台上的服务可以被其他用户订阅和调用。因此平台上存在一个微服务模块service_management是负责做服务调用的，相当于对服务的请求不是直接发送给该服务，而是先请求本平台（的service_management模块），然后该模块再通过解析请求中的信息去远程调用该服务。类似于API网关，但是API网关只是简单地做请求的转发，而本场景的service_management模块还要对请求进行解析（包括路径、参数等信息），再根据解析后的信息重新构造请求进行远程调用。</p><h2 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h2><p>本节直观地贴一下代码，欣赏一下大佬的精妙设计。</p><h3 id="1-抽象类Invoker-java"><a href="#1-抽象类Invoker-java" class="headerlink" title="1. 抽象类Invoker.java"></a>1. 抽象类Invoker.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    String invokeAddress;</span><br><span class="line"></span><br><span class="line">    String path;</span><br><span class="line"></span><br><span class="line">    HttpMethod method;</span><br><span class="line"></span><br><span class="line">    Descriptor descriptor;</span><br><span class="line"></span><br><span class="line">    List&lt;Parameter&gt; parameters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invokeWith</span><span class="params">(String requestBody, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        HttpHeaders httpHeaders = createHeaders(request);</span><br><span class="line">        String url = createUrl(request);</span><br><span class="line">        log.info(<span class="string">"Request URL is: &#123;&#125;"</span>, url);</span><br><span class="line">        <span class="keyword">return</span> doInvoke(url, httpHeaders, requestBody, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HttpHeaders <span class="title">createHeaders</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        HttpHeaders httpHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        httpHeaders.setContentType(MediaType.valueOf(request.getContentType()));</span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parameters.stream()</span><br><span class="line">                    .filter(parameter -&gt; parameter.getIn().equals(ParamIn.HEAD))</span><br><span class="line">                    .forEach(parameter -&gt; &#123;</span><br><span class="line">                        String keyName = parameter.getSchema().getKeyName();</span><br><span class="line">                        httpHeaders.set(keyName, Optional.ofNullable(request.getHeader(keyName))</span><br><span class="line">                                .orElse(getDefaultValueOfParameter(parameter)));</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> httpHeaders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">createUrl</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.invokeAddress + createPath(request) + createParameterList(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">createPath</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String res = <span class="keyword">this</span>.path;</span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;Parameter&gt; inPathParameters = parameters</span><br><span class="line">                    .stream()</span><br><span class="line">                    .filter(parameter -&gt; parameter.getIn().equals(ParamIn.PATH))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            <span class="keyword">for</span> (Parameter parameter : inPathParameters) &#123;</span><br><span class="line">                String keyName = parameter.getSchema().getKeyName();</span><br><span class="line">                String value = Optional.ofNullable(request.getParameter(keyName))</span><br><span class="line">                        .orElse(getDefaultValueOfParameter(parameter));</span><br><span class="line">                res = res.replace(<span class="string">"&#123;"</span> + keyName + <span class="string">"&#125;"</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">createParameterList</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"?"</span>);</span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parameters.stream()</span><br><span class="line">                    .filter(parameter -&gt; parameter.getIn().equals(ParamIn.QUERY))</span><br><span class="line">                    .forEach(parameter -&gt; &#123;</span><br><span class="line">                        String keyName = parameter.getSchema().getKeyName();</span><br><span class="line">                        String value = Optional.ofNullable(request.getParameter(keyName))</span><br><span class="line">                                .orElse(getDefaultValueOfParameter(parameter));</span><br><span class="line">                        sb.append(keyName);</span><br><span class="line">                        sb.append(<span class="string">"="</span>);</span><br><span class="line">                        sb.append(value);</span><br><span class="line">                        sb.append(<span class="string">"&amp;"</span>);</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        String res = sb.toString();</span><br><span class="line">        <span class="keyword">return</span> res.substring(<span class="number">0</span>, res.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getDefaultValueOfParameter</span><span class="params">(Parameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(parameter)</span><br><span class="line">                .map(Parameter::getSchema)</span><br><span class="line">                .map(Descriptor::getDefaultValue)</span><br><span class="line">                .map(Object::toString)</span><br><span class="line">                .orElse(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现多态服务调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url         服务地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpHeaders HttpHeaders</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestBody 调用体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request     调用请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">doInvoke</span><span class="params">(String url, HttpHeaders httpHeaders, String requestBody, HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-派生类JsonInvoker-java（处理application-json格式的调用）"><a href="#2-派生类JsonInvoker-java（处理application-json格式的调用）" class="headerlink" title="2. 派生类JsonInvoker.java（处理application/json格式的调用）"></a>2. 派生类JsonInvoker.java（处理application/json格式的调用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InvokerType</span>(contentType = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonInvoker</span> <span class="keyword">extends</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInvoke</span><span class="params">(String url, HttpHeaders httpHeaders, String requestBody, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        JsonNode content = JsonUtil.readTree(requestBody);</span><br><span class="line">        String reqBody = descriptor.generateJsonNodeFromJson(content).toString();</span><br><span class="line">        HttpEntity&lt;String&gt; httpEntity = <span class="keyword">new</span> HttpEntity&lt;&gt;(reqBody, httpHeaders);</span><br><span class="line">        ResponseEntity&lt;String&gt; res = ContextUtil.ctx.getBean(RestTemplate.class)</span><br><span class="line">                .exchange(url, method, httpEntity, String.class);</span><br><span class="line">        <span class="keyword">return</span> res.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-派生类MultiPartFormInvoker-java（处理multipart-form-data格式的调用）"><a href="#3-派生类MultiPartFormInvoker-java（处理multipart-form-data格式的调用）" class="headerlink" title="3. 派生类MultiPartFormInvoker.java（处理multipart/form-data格式的调用）"></a>3. 派生类MultiPartFormInvoker.java（处理multipart/form-data格式的调用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InvokerType</span>(contentType = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiPartFormInvoker</span> <span class="keyword">extends</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInvoke</span><span class="params">(String url, HttpHeaders httpHeaders, String requestBody, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        MultiValueMap&lt;String, Object&gt; parameterMap = createParameterMap(request);</span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = <span class="keyword">new</span> HttpEntity&lt;&gt;(parameterMap, httpHeaders);</span><br><span class="line">        ResponseEntity&lt;String&gt; res = ContextUtil.ctx.getBean(RestTemplate.class)</span><br><span class="line">                .exchange(url, method, httpEntity, String.class);</span><br><span class="line">        <span class="keyword">return</span> res.getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MultiValueMap&lt;String, Object&gt; <span class="title">createParameterMap</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        MultiValueMap&lt;String, Object&gt; parameterMap = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;</span><br><span class="line"></span><br><span class="line">        ObjectDescriptor objectDescriptor = (ObjectDescriptor) descriptor;</span><br><span class="line">        <span class="keyword">for</span> (Descriptor child : objectDescriptor.getChildren()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child.getType().equals(<span class="string">"file"</span>)) &#123;</span><br><span class="line">                parameterMap.add(child.getKeyName(), multipartRequest.getFile(child.getKeyName()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parameterMap.add(child.getKeyName(), multipartRequest.getParameter(child.getKeyName()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parameterMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注解类InvokerType-java"><a href="#4-注解类InvokerType-java" class="headerlink" title="4. 注解类InvokerType.java"></a>4. 注解类InvokerType.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InvokerType &#123;</span><br><span class="line">    <span class="function">String <span class="title">contentType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-工厂类InvokerFactory-java"><a href="#5-工厂类InvokerFactory-java" class="headerlink" title="5. 工厂类InvokerFactory.java"></a>5. 工厂类InvokerFactory.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Class&lt;? extends Invoker&gt;&gt; registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String contentType, Class&lt;? extends Invoker&gt; clazz)</span> </span>&#123;</span><br><span class="line">        registry.put(contentType, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Invoker <span class="title">createInstance</span><span class="params">(String contentType, String invokeAddress, Api api)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!registry.containsKey(contentType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(ResultCode.NON_SUPPORT_CONTENT_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Invoker invoker = registry.get(contentType).newInstance();</span><br><span class="line">                invoker.setInvokeAddress(invokeAddress);</span><br><span class="line">                invoker.setPath(api.getPath());</span><br><span class="line">                invoker.setMethod(api.getMethod());</span><br><span class="line">                invoker.setParameters(api.getParameters());</span><br><span class="line">                invoker.setDescriptor(api.getRequestBody().getContent().get(contentType));</span><br><span class="line">                <span class="keyword">return</span> invoker;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-工厂配置类InvokerFactoryConfigure-java"><a href="#6-工厂配置类InvokerFactoryConfigure-java" class="headerlink" title="6. 工厂配置类InvokerFactoryConfigure.java"></a>6. 工厂配置类InvokerFactoryConfigure.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerFactoryConfigure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">invokeFactoryInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (args) -&gt; &#123;</span><br><span class="line">            Reflections reflections = <span class="keyword">new</span> Reflections(<span class="string">"cn.ist.msplatform.servicemanagement.model.invoke"</span>);</span><br><span class="line">            <span class="keyword">for</span> (Class clazz : reflections.getTypesAnnotatedWith(InvokerType.class)) &#123;</span><br><span class="line">                InvokerType invokerType = (InvokerType) clazz.getAnnotation(InvokerType.class);</span><br><span class="line">                InvokerFactory.register(invokerType.contentType(), clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-服务调用逻辑Api-java"><a href="#7-服务调用逻辑Api-java" class="headerlink" title="7. 服务调用逻辑Api.java"></a>7. 服务调用逻辑Api.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(of = &#123;<span class="string">"path"</span>, <span class="string">"method"</span>&#125;)</span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 接口路径 */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** HTTP方法 */</span></span><br><span class="line">    <span class="keyword">private</span> HttpMethod method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 接口描述 */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 请求体 */</span></span><br><span class="line">    <span class="keyword">private</span> RequestBody requestBody;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数列表 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Parameter&gt; parameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 响应列表 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Response&gt; responses;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invokeWith</span><span class="params">(Instance instance, String requestBody, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String invokeAddress = instance.getInvokeAddress();</span><br><span class="line">        Invoker invoker = InvokerFactory.createInstance(request.getContentType(), invokeAddress, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> invoker.invokeWith(requestBody, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h3 id="1-Java多态设计"><a href="#1-Java多态设计" class="headerlink" title="1. Java多态设计"></a>1. Java多态设计</h3><p>首先根据<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md" target="_blank" rel="noopener">OpenAPI 3.0规范</a>，HTTP调用的media type有多种，比如：</p><blockquote><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;   text/plain; charset=utf-8</span><br><span class="line">&gt;   application/json</span><br><span class="line">&gt;   application/vnd.github+json</span><br><span class="line">&gt;   application/vnd.github.v3+json</span><br><span class="line">&gt;   application/vnd.github.v3.raw+json</span><br><span class="line">&gt;   application/vnd.github.v3.text+json</span><br><span class="line">&gt;   application/vnd.github.v3.html+json</span><br><span class="line">&gt;   application/vnd.github.v3.full+json</span><br><span class="line">&gt;   application/vnd.github.v3.diff</span><br><span class="line">&gt;   application/vnd.github.v3.patch</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>最常用的种类是application/json，即requestbody是json格式，能cover掉大部分的服务调用场景。但是当需要调用文件参数时，就需要传输表单数据，对应的media type是multipart/form-data。目前需求的主要就是这两个调用模式，未来可能还会增加对新的media type的调用模式。</p><p>对于以上的需求场景，最naive的实现方法就是写一个switch-case结构，通过检查HttpServletRequest的content type（对应OpenAPI规范的media type），来选择对应的调用模式。这样实现的程序扩展型差，每当有新的media type调用需求时，就需要新增case，并为其编写相应的调用逻辑。</p><p>相比之下，应用了Java多态可以更优雅地实现以上需求场景，将所有的调用逻辑都抽象到一个抽象基类Invoker中，并在其中留了一个抽象方法doInvoke，对不同的调用模式有两个对应的派生类JsonInvoker和MultiPartFormInvoker去继承Invoker，并且按照各自的调用逻辑重写（override）基类的doInvoke方法，当然后续根据需求的扩充，可以增加对应的派生类。在Api.java中服务调用的时候，只需要<strong>面对抽象基类Invoker编程</strong>， 派生类的功能可以被基类的方法或引用变量所调用（代码29行，<code>invoker.invokeWith()</code>调用的实际上是某个派生类的<code>invokeWith()</code>方法，而非基类的），这叫<strong>向后兼容</strong>，提高程序可扩充性和可维护性。考虑<strong>面向接口编程，而非面向实现编程</strong>的Java设计原则，这里是<strong>面向抽象基类编程，而非面向派生类编程</strong>。这样就实现了一个多态服务调用。</p><h3 id="2-工厂模式设计"><a href="#2-工厂模式设计" class="headerlink" title="2. 工厂模式设计"></a>2. 工厂模式设计</h3><p>根据上面的多态设计，在服务调用的时候需要根据调用模式创建对应的派生类的实例，去执行调用过程。</p><p>最naive的做法依然是写一个switch-case结构，通过检查HttpServletRequest的content type，去创建对应的派生类实例，但这样的实现方式依然存在上述扩展型差的缺陷。</p><p>相比之下，采用工厂风格的设计模式可以非常优雅地实现这个需求场景。如Api.java的代码28行所示，实例的创建逻辑并不会直接暴露给调用者（即Api.java），而是封装到工厂中执行，让工厂去决定应该创建什么类型的派生类实例。调用者只需要关心这个创建实例的接口（工厂提供），而不需要关心实现逻辑。</p><p>但上面的设计，仅仅是把switch-case结构从调用者里移到了工厂里，也就是工厂在决定创建什么样的派生类实例的时候，依然需要通过检查HttpServletRequest的content type。下面又是一个优雅的解决方案：注册表。</p><p>见InvokerFactory.java的代码第2行，<code>Map&lt;String, Class&lt;? extends Invoker&gt;&gt; registry</code>是一个注册表，把所有的派生类及其对应的content type注册于其中，这样创建派生类实例的时候只需要1行代码就能搞定（第14行），相比于冗长的switch-case结构有了很大的优化。</p><p>但是又有一个新问题：这个注册表要怎么初始化呢？目前只有两个派生类，那么初始化的时候就注册这两个派生类就行，但是如果后续要增加新的派生类，初始化的时候又要新增一条<code>map.put</code>操作，并且这个操作是写死的，这样的代码适应性比较差，不够灵活。为了解决这个问题，下面又是一个优雅的设计：自定义注解类。</p><p>如InvokerType.java所示，这个自定义的注解类只有一个contentType字段，对应注册表registry中的key，注解在派生类上，对应registry中的value。<strong>这样就通过注解把contentType和派生类关联在了一起</strong>，初始化注册表的时候只需要使用Java提供的Reflections反射框架，扫描指定路径下所有被InvokerType注解的派生类，并将关联关系写到注册表中即可（见InvokerFactoryConfig.java）。而且后续有新增的派生类，只需要添加对应的注解即可，这样的代码设计更加灵活，适应性强。当然，扫描所有派生类并注册这一过程是工厂注册表的初始化，应该在项目启动的时候进行。SpringBoot提供了一个简单的方式CommandLineRunner来实现预先数据的加载。</p>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Spring Boot项目生成OpenAPI3.0文档</title>
      <link href="/2020/08/05/%E4%B8%BASpring%20Boot%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90OpenAPI%E6%96%87%E4%BB%B6/"/>
      <url>/2020/08/05/%E4%B8%BASpring%20Boot%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90OpenAPI%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用<strong>springdoc-openapi</strong>库为Spring Boot项目自动生成OpenAPI3.0规范的接口描述文档。</p></blockquote><a id="more"></a><ul><li><p><strong><a href="https://www.cnblogs.com/liululee/p/11925987.html" target="_blank" rel="noopener">本文参考文档</a></strong></p></li><li><p><strong><a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md" target="_blank" rel="noopener">OpenAPI 3.0规范</a></strong></p></li></ul><p>首先在pom.xml文件中添加springdoc-openapi的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.45<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完成后，启动Spring Boot程序，通过项目的ip、端口加上默认路径<strong>/v3/api-docs</strong>访问自动生成的OpenAPI 3.0文档：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghfy5at35dj31hc0u0duh.jpg" alt></p><p>如果想要自定义路径，可在application.properties文件中指定：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">springdoc.api-docs.path=/api-docs</span> <span class="comment">#自定义路径为/api-docs</span></span><br></pre></td></tr></table></figure><p>以上方法访问的OpenAPI文档是JSON格式，可读性非常差，可以通过访问默认路径<strong>/v3/api-docs.yaml</strong>下载yaml格式的文件（如果自定义路径，注意对路径作相应的调整）：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghfygv24nhj31hc0u00yc.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> OpenAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序数据库调研</title>
      <link href="/2020/05/12/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E7%A0%94/"/>
      <url>/2020/05/12/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<blockquote><p>研一在实验室航天微服务项目的开发中，需要引入时序数据库进行日志数据的存取，本文档是对时序数据库的调研。</p></blockquote><a id="more"></a><h2 id="一、时序数据"><a href="#一、时序数据" class="headerlink" title="一、时序数据"></a>一、时序数据</h2><p>时序数据即时间序列数据，指按照时间先后顺序变化、带时间标签的数据，具有以下特征：</p><ul><li>采样频率快</li><li>测点多信息量大</li><li>数据按照时间顺序产生，一经产生不再变化</li><li>没有关系数据的并发写入/更改情况</li><li>单点数据价值小，对数据一致性要求没有业务数据严格</li></ul><h2 id="二、时序数据库"><a href="#二、时序数据库" class="headerlink" title="二、时序数据库"></a>二、时序数据库</h2><p>与传统关系型数据库相比，时序数据库：</p><ul><li>不仅记录了数据的当前值，而且记录了所有的历史数据（相当于关系型数据库+时间戳键值，但后者仅能应对少量的数据）</li><li>应对海量时序数据点的并发写入（批量写入，先写入内存，再周期性dump为不可变文件存储）</li><li>支持查询时的海量数据分组聚合运算</li><li>利用时间递增、维度重复、指标平滑变化特性，提高数据压缩比，存储成本低</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghfzkj2vwnj30n20bd453.jpg" alt></p><p>如上图是时序数据库的一般结构：</p><ul><li><strong>metric</strong>：度量，相当于关系型数据库的table</li><li><strong>data point</strong>：数据点，相当于关系型数据库的row</li><li><strong>timestamp</strong>：时间戳，代表数据点产生的时间</li><li><strong>field</strong>：数据字段，一般存放随时间戳变化而变化的数据</li><li><strong>tag</strong>：标签，索引列，标识数据点来源的属性信息，一般不随时间戳变化<ul><li>timestamp加上所有的tags构成primary key</li><li>具有相同的tagset值的数据点构成一条series曲线，横坐标为时间轴</li></ul></li></ul><h2 id="三、InfluxDB"><a href="#三、InfluxDB" class="headerlink" title="三、InfluxDB"></a>三、InfluxDB</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>目前开源时序数据库中排名第一的是InfluxDB：</p><ul><li>提供HTTP接口</li><li>支持类SQL查询，传统数据库使用者上手更快</li><li>安装管理简单</li><li>字段属性可动态扩充，比于传统关系型数据库更灵活</li><li>存储空间占用低（针对不同数据类型采用不同的压缩算法）</li><li>读写性能高（TSM tree优化）</li><li>支持高速的海量数据分组聚合运算</li></ul><table><thead><tr><th align="center">序号</th><th align="center">对比数据库</th><th align="center">写入速度</th><th align="center">读取速度</th><th align="center">存储空间占用</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Cassandra</td><td align="center">快4.5倍</td><td align="center">快45倍</td><td align="center">少2.1倍</td></tr><tr><td align="center">2</td><td align="center">Elasticsearch</td><td align="center">快6.1倍</td><td align="center">快8.2倍</td><td align="center">少2.5倍</td></tr><tr><td align="center">3</td><td align="center">MongoDB</td><td align="center">快2.4倍</td><td align="center">快5.7倍</td><td align="center">少20倍</td></tr><tr><td align="center">4</td><td align="center">OpenTSDB</td><td align="center">快5倍</td><td align="center">快3.64～4倍</td><td align="center">少16.5倍</td></tr></tbody></table><blockquote><p>引自 徐化岩,初彦龙.基于influxDB的工业时序数据库引擎设计[J].计算机应用与软件,2019,36(09):33-36+40.</p></blockquote><h3 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2. 存储结构"></a>2. 存储结构</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghfzwuwoqfj30hw0b0755.jpg" alt></p><ul><li><strong>database</strong>：数据库，可在这一层级做读写权限控制和数据保留时间</li><li><strong>measurement</strong>：表，包含time，tags和fields三种字段</li><li><strong>tag</strong>：索引字段</li><li><strong>field</strong>：数据字段，通常随时间变化</li><li><strong>point</strong>：红色的一行就是一个数据点，每个point由time+n个tag定位</li></ul><h3 id="3-实例尝试"><a href="#3-实例尝试" class="headerlink" title="3. 实例尝试"></a>3. 实例尝试</h3><p>如下图所示的三个红框内的列设定为tag字段，因为其不随时间变化，余下的content和processId为field字段。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghg021d292j30pw08yjw9.jpg" alt></p><p>利用InfluxDB提供的分组聚合函数，查询符合条件且最近的三条point：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghg02byv3fj30pk04ftaq.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghg02hymgcj30rn04edhw.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时序数据库 </tag>
            
            <tag> InfluxDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook关闭端口占用</title>
      <link href="/2020/04/24/MacBook%E5%85%B3%E9%97%AD%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/"/>
      <url>/2020/04/24/MacBook%E5%85%B3%E9%97%AD%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下MacBook查询并关闭占用某端口的进程的方法</p></blockquote><a id="more"></a><p><strong>问题：</strong>运行Spring Boot的项目，端口是8080，结果报错端口已被占用。MacBook下查询并关闭占用某端口的进程的方法如下。</p><p><strong>解决：</strong></p><ol><li>终端键入：<code>lsof -i:8080</code> 找到占用端口8080的进程的PID</li><li>终端键入：<code>kill PID</code> </li></ol>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook核显/独显切换</title>
      <link href="/2020/04/24/MacBook%E6%A0%B8%E6%98%BE:%E7%8B%AC%E6%98%BE%E5%88%87%E6%8D%A2/"/>
      <url>/2020/04/24/MacBook%E6%A0%B8%E6%98%BE:%E7%8B%AC%E6%98%BE%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下MacBook核心显卡和独立显卡手动切换的方法（15英寸款）</p></blockquote><a id="more"></a><p><strong>问题：</strong>有时候看直播、视频，特别是打微信语音电话时MacBook会发烫，是因为MacBook自动切换到了独立显卡的原因。但是实际上大部分的使用情况，核显基本都能够handle，且不会出现机器发烫的情况。下面记录下手动切换核显和独显的方法。</p><p><strong>解决：</strong>终端键入如下命令：<code>sudo pmset -a GPUSwitch 0</code>，其中参数”0”可以有下面三种选择：</p><ul><li>0: 强制使用核显</li><li>1: 强制使用独显</li><li>2: 自动切换显卡</li></ul>]]></content>
      
      
      <categories>
          
          <category> MacBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook扬声器失效的问题</title>
      <link href="/2020/04/24/MacBook%E6%89%AC%E5%A3%B0%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/24/MacBook%E6%89%AC%E5%A3%B0%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下如何解决MacBook扬声器失效的问题</p></blockquote><a id="more"></a><p><strong>问题：</strong>时候 MacBook 从睡眠状态恢复之后扬声器没有声音，这是 Mac OS X 系统的一个 Bug。这是因为 Mac OS X 的核心音频守护进程「coreaudiod」出了问题，虽然简单的重启电脑就能解决，但是如果此时开启了很多程序后者有其他情况不想重启电脑的话，可以按照下面的方法解决此问题。</p><p><strong>解决：</strong>在终端运行命令行<code>sudo killall coreaudiod</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> MacBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook触控板失效的问题</title>
      <link href="/2019/11/04/MacBook%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/11/04/MacBook%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下如何解决MacBook触控板失效的问题</p></blockquote><a id="more"></a><p><strong>问题：</strong>MacBook的使用过程中，偶尔会出现触控板失效的问题，这些问题多发生于刚打开MacBook的时候，比如双指缩放、四指切换桌面等手势失效，触控栏虚拟按键失效等。</p><p><strong>解决：</strong>设定睡眠触发角，当发生上述情况时，将鼠标移到触发角使MacBook进入睡眠状态，再唤醒后就恢复正常了。</p><p>设置过程：系统偏好设置》调度中心》触发角，我将左下角设置为睡眠触发角：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8m4keijq0j31140syajb.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> MacBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发中会话管理的三种方式</title>
      <link href="/2019/10/25/Web%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/10/25/Web%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结Web开发中会话管理的三种方式：基于Server端Session的管理方式、基于Cookie的管理方式、基于Token的管理方式。</p></blockquote><a id="more"></a><p>HTTP是无状态性的，一次请求结束，连接断开，下次服务器再收到请求，就不知道这个请求是哪个用户发过来的。为了让服务端准确定位HTTP请求是由哪个用户发起的，从而判断该用户是否有权限访问请求的服务，需要有用户状态管理，即常说的<strong>会话管理</strong>，其涉及周期是一个用户从登录到退出应用的一段时间。常见的web应用的会话管理有三种方式：</p><ul><li>基于Server端Session的管理方式</li><li>基于Cookie的管理方式</li><li>基于Token的管理方式</li></ul><h2 id="一、基于Server端Session的管理方式"><a href="#一、基于Server端Session的管理方式" class="headerlink" title="一、基于Server端Session的管理方式"></a>一、基于Server端Session的管理方式</h2><p>在早期的web应用中，通常使用服务端session来管理用户的会话，其流程图如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g884ze84hpj30gs0atjse.jpg" alt></p><p>（1）服务端session是用户<strong>第一次访问</strong>（可以是未登录的访问）应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个<strong>唯一的</strong>sessionid，以保证每个用户都有一个不同的session对象。</p><p>（2）服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。</p><p>（3）session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。</p><p>（4）session在一开始并不具备会话管理的作用。它只有在用户<strong>登录</strong>认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单：只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。</p><p><strong>优点：</strong></p><p>（1）主流的web开发平台(java/.net/php)都原生支持这种会话管理模式，且开发简单，很多后端开发人员入门都使用过。</p><p>（2）安全性好，只要服务端创建的、cookie中保存的sessionid这个字串足够随机，攻击者就不能轻易冒充他人的sessionid进行操作，除非通过CSRF（跨站请求伪造，攻击者挟持了登录还未过期的浏览器，从而盗用了用户的身份，执行非用户本意的操作）或HTTP劫持的方式。即使冒充成功，也必须被冒充用户的session中包含有效的登录凭证才行。</p><p><strong>缺点：</strong></p><p>（1）session会话信息存储在服务器的内存中，当在线量比较多时消耗大量内存。</p><p>（2）同个应用集群部署时，不同服务器间session共享的问题。某个用户的session只存在于一台服务器的内存中，下次请求如果没有被转发到那台服务器，就拿不到自己session中登录凭证等的信息了。</p><p>（3）多个应用共享session时的跨域问题。多个应用可能部署的主机不一样，要在各个应用做好cookie跨域的处理。</p><h2 id="二、基于Cookie的管理方式"><a href="#二、基于Cookie的管理方式" class="headerlink" title="二、基于Cookie的管理方式"></a>二、基于Cookie的管理方式</h2><p>上一种方式将登录凭证放在服务器的session中，会增加服务器的内存负担和服务端架构的复杂性。本方案将用户的登录凭证直接放在客户端的cookie中，后续请求会带着这个登录凭证去访问服务器，流程图如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8a98s9386j30gs0b3757.jpg" alt></p><p>（1）用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id，凭证创建时间和过期时间三个值。</p><p>（2）服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。cookie的名字必须固定（如ticket），因为后面再获取的时候，还得根据这个名字来获取cookie值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。</p><p>（3）用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</p><p><strong>优点：</strong></p><p>（1）实现无状态的服务端。服务端只需要对用户传来的cookie登录凭证进行验证即可，无需保存用户的状态信息，解决了服务端内存压力大的问题</p><p>（2）同一个应用集群部署的时候，因为验证登录凭证的代码在不同的服务器上都是一样的，因此不管是哪个服务器在处理用户请求，都能够对用户的登录凭证进行相同的验证逻辑。</p><p>（3）不同应用的集群，只要这些应用的登录逻辑相同，也能够实现会话共享。保证不同应用登录逻辑里的签名算法、加密算法、解密算法、密钥等一致即可。总而言之，需要算法保持完全一致。</p><p><strong>缺点：</strong></p><p>（1）cookie大小有限制，如果加密签名串太长导致登录凭证太大，就会占用大量的cookie空间，这样，当别的业务场景需要用cookie存储数据的时候，可能就不够用了。</p><p>（2）客户端的每次请求都会传送cookie，对访问性能有影响。</p><p>（3）依然存在和第一种基于session管理方式相同的跨域问题，因为毕竟还是要用到cookie。</p><p>（4）登录凭证过期时间刷新的问题。</p><h2 id="三、基于Token的管理方式"><a href="#三、基于Token的管理方式" class="headerlink" title="三、基于Token的管理方式"></a>三、基于Token的管理方式</h2><p>前两种会话管理方案都有一个共同的缺陷：因为都用到cookie，所以只适合做浏览器应用，不适合做native app，都不适合来用作纯api服务（比如RESTful API）的登录认证。因此有第三种基于token的管理方式，流程图如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8adbi7ywnj30gs09udgq.jpg" alt></p><p>虽然从流程和实现上来说，这种方式和基于cookie的管理方式没有太多区别，但不通过cookie进行登录凭证的传递，而是每次请求的时候，主动把token（登录凭证）加到http header里面或者url后面，所以即使在native app中也能使用它来调用我们通过web发布的api的接口，可以用来做纯api服务的登录认证。</p><p><strong>优点：</strong></p><p>（1）第二种基于cookie的管理方式的全部优点。</p><p>（2）如上所述，同时适用于网页app和native app。在网页应用中，token可以存于localStorage或者sessionStorage中，每次发ajax请求的时候，都把token拿出来放到请求头里即可。不过如果是非接口的请求，比如通过点击链接请求一个页面这种，是无法自动带上token的，因此只适用于纯api接口的请求服务（比如RESTful API）。</p><p><strong>缺点：</strong></p><p>（1）在web应用里，即使是不使用cookie，使用ajax请求也会存在跨域问题。比如应用部署在a.com，api服务部署在b.com，从a.com里发ajax请求到b.com，默认情况下也会报跨域错误，这个问题可以用CORS（<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享</a>）的方式解决。</p><p>（2）与第二种基于cookie的管理方式相同的登录凭证刷新的问题。可以在每次请求过来验证token有效之后，自动把token的失效时间延长，再把新的token返回给客户端，客户端监测到这个返回的新的token，就替换掉原来的token。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Web </tag>
            
            <tag> 会话管理 </tag>
            
            <tag> Session </tag>
            
            <tag> Cookie </tag>
            
            <tag> Token </tag>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook上Spring Boot启动慢的问题</title>
      <link href="/2019/10/25/MacBook%E4%B8%8ASpring%20Boot%E5%90%AF%E5%8A%A8%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/25/MacBook%E4%B8%8ASpring%20Boot%E5%90%AF%E5%8A%A8%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一下如何解决MacBook上Spring Boot应用启动慢的问题</p></blockquote><a id="more"></a><p><strong>问题：</strong>做沈阿姨课程项目时，使用Spring Boot框架进行开发，我发现一个很轻量级的小demo跑起来居然需要22秒！后面随着项目的扩充，反而启动时间没有明显变化，依然是22秒左右。而且我发现每次启动程序，控制台要等待很久才打印出第一行：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8a74uz7jtj31ao00wwgq.jpg" alt></p><p>而且等待的时候IDEA的反应比较卡顿，因此猜测是连接Java虚拟机所用时间太长，即定位’127.0.0.1’(localhost)耗费了很多时间。</p><p><strong>解决：</strong>打开“访达”窗口，快捷键command+shift+G前往文件夹/etc/hosts，将host的内容改为：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8a7at10p5j30zk0mwdjd.jpg" alt></p><p>主机名”liumudeMacBook-Pro.local”每个人的电脑是不一样的，在终端输入命令：</p><p><code>$ hostname</code></p><p>即可查到自己的主机名。</p><p>另外，直接在hosts文件中修改的话，会提示没有权限：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8a7h87bgcj30nc076mzb.jpg" alt></p><p>比较方便的做法是拷贝一个副本，在副本中修改，然后将副本拖到/etc目录中，覆盖掉原来的hosts文件即可。</p><p>修改完毕，重新启动我的Spring Boot应用，2秒完事。</p>]]></content>
      
      
      <categories>
          
          <category> MacBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot+JWT+MongoDB实现权限控制</title>
      <link href="/2019/10/22/Spring+Boot+JWT+MongoDB%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/10/22/Spring+Boot+JWT+MongoDB%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>沈阿姨的课程项目，<a href="http://ist.sjtu.edu.cn" target="_blank" rel="noopener">IST实验室</a>五个研一的同学组队，实现一个基于微服务的工业流程管理平台。在sprint1中我负责平台的权限控制功能，这里记录一下思路和代码实现过程。</p></blockquote><a id="more"></a><ul><li><strong>用JWT进行权限控制是基于Token的会话管理思想，参考我另一篇<a href="https://loumoon.github.io/2019/10/25/Web开发中会话管理的三种方式/">介绍会话管理的博客</a>。</strong></li></ul><h2 id="一、JWT"><a href="#一、JWT" class="headerlink" title="一、JWT"></a>一、JWT</h2><h3 id="1-什么是JWT"><a href="#1-什么是JWT" class="headerlink" title="1.什么是JWT"></a>1.什么是JWT</h3><p>JSON Web Token（JWT），是为了在网络应用环境间传递声明而执行的一种基于JSON的开放<strong>标准</strong>。定义了一种简洁的、自包含的方法用于通信双方之间以JSON对象的形式安全地传递信息，<strong>数字签名的存在可以保证这些信息是可信的，没有经过伪造的</strong>。</p><h3 id="2-JWT请求与响应流程"><a href="#2-JWT请求与响应流程" class="headerlink" title="2.JWT请求与响应流程"></a>2.JWT请求与响应流程</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8afmwyigyj30pm0dhdgp.jpg" alt></p><p>（1）用户使用账号和密码，通过POST请求访问登录API接口，进行登录</p><p>（2）服务端登录验证成功，根据密钥生成一个JWT</p><p>（3）服务端将生成的JWT返回给浏览器</p><p>（4）浏览器下次像服务端发送请求，需要将JWT放在请求头中</p><p>（5）服务端检查请求头中的JWT，通过签名算法和密钥验证其合法性，并从中解码用户信息</p><p>（6）返回响应给浏览器</p><h3 id="3-JWT的结构"><a href="#3-JWT的结构" class="headerlink" title="3.JWT的结构"></a>3.JWT的结构</h3><p>JWT包含三部分：</p><ul><li>Header：头部，包含token类型和加密算法</li><li>Payload：负载，存放有效信息</li><li>Signature：签名/签证，标识JWT的合法性</li></ul><p>（1）Header头部是一个包含了两个部分的JSON对象：签名使用的算法（通常是HS256或者RSA）和token类型（JWT）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）Payload负载也是一个JSON对象，官方提供了一些不强制使用的字段:</p><ul><li>iss (issuer): jwt签发者</li><li>sub (subject): 面向的用户(jwt所面向的用户)</li><li>aud (audience): 接收jwt的一方</li><li>exp (expiration time): 过期时间戳(jwt的过期时间，这个过期时间必须要大于签发时间)</li><li>nbf (not before): 定义在什么时间之前，该jwt都是不可用的</li><li>iat (issued at): jwt的签发时间</li><li>jti (jwt id): jwt的唯一身份标识，主要用来作为一次性<code>token</code>,从而回避重放攻击</li></ul><p>当然除了以上之外也可以自定义字段，Payload示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）Signature密钥是对前两部分的签名，标识JWT的合法性。首先要制定一个仅服务器可见的密钥（secret），然后使用Header里指定的签名算法（HS256）按照下面公式生成签名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名后把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”.”分隔，就产生了最终的JWT，返回给用户。</p><h2 id="二、项目权限控制功能的实现"><a href="#二、项目权限控制功能的实现" class="headerlink" title="二、项目权限控制功能的实现"></a>二、项目权限控制功能的实现</h2><blockquote><p>先贴上项目的源代码地址：<a href="https://github.com/loumoon/Sping-Boot-Mongodb-JWT" target="_blank" rel="noopener">Sping-Boot-Mongodb-JWT</a></p></blockquote><h3 id="1-pom-xml文件配置依赖"><a href="#1-pom-xml文件配置依赖" class="headerlink" title="1.pom.xml文件配置依赖"></a>1.pom.xml文件配置依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.edu.sjtu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>industry_backend<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>industry_backend<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.58<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Spring-Boot配置文件application-properties"><a href="#2-Spring-Boot配置文件application-properties" class="headerlink" title="2.Spring Boot配置文件application.properties"></a>2.Spring Boot配置文件application.properties</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.data.mongodb.host = localhost</span><br><span class="line">spring.data.mongodb.port = 27017</span><br><span class="line">spring.data.mongodb.database = industry</span><br><span class="line">server.port = 8080</span><br></pre></td></tr></table></figure><p>项目要连接本地MongoDB，数据库名称为’industry’。</p><h3 id="3-实体类User-java"><a href="#3-实体类User-java" class="headerlink" title="3.实体类User.java"></a>3.实体类User.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId; <span class="comment">// 工号</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer role;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tolerate</span></span><br><span class="line">    User() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类对应MongoDB数据库中的’user’表。用户使用工号userId和密码password登录，id属性是向MongoDB插入数据会自动生成的字段，在业务逻辑中一般不使用。</p><h3 id="4-持久化数据层UserRepository-java"><a href="#4-持久化数据层UserRepository-java" class="headerlink" title="4.持久化数据层UserRepository.java"></a>4.持久化数据层UserRepository.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findUserByUserId</span><span class="params">(<span class="keyword">final</span> String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要继承MongoRepository接口即可，太好用了叭！</p><h3 id="5-JWT工具类JWTUtil-java"><a href="#5-JWT工具类JWTUtil-java" class="headerlink" title="5.JWT工具类JWTUtil.java"></a>5.JWT工具类JWTUtil.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        Algorithm algorithm = Algorithm.HMAC256(JWTConstant.SECRET_KEY);</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> Date(System.currentTimeMillis() + JWTConstant.VALIDITY_PERIOD))</span><br><span class="line">                .withAudience(user.getUserId())</span><br><span class="line">                .withClaim(<span class="string">"role"</span>, user.getRole())</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decodeUserId</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.decode(token).getAudience().get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">decodeRole</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.decode(token).getClaim(<span class="string">"role"</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(JWTConstant.SECRET_KEY)).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jwtVerifier.verify(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(RespStatus.INVALID_TOKEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JWT生成、验证、解码的逻辑写在了一个工具类中。生成JWT时，将用户的userId和<strong>角色role</strong>塞了进去，方便对后面请求进行权限验证，不需要再访问数据库查用户权限了。</p><h3 id="6-业务逻辑层UserService-java"><a href="#6-业务逻辑层UserService-java" class="headerlink" title="6.业务逻辑层UserService.java"></a>6.业务逻辑层UserService.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">signIn</span><span class="params">(String userId, String password)</span> </span>&#123;</span><br><span class="line">        User user = findUserById(userId);</span><br><span class="line">        <span class="keyword">if</span>(!user.getPassword().equals(password)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(RespStatus.WRONG_PASSWORD, <span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            String token = JWTUtil.encode(user);</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signUp</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userRepository.findUserByUserId(user.getUserId()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(RespStatus.EXIST_ACCOUNT, <span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        User user = userRepository.findUserByUserId(userId);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(RespStatus.NON_ACCOUNT, <span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录注册的业务逻辑实现。如果登录成功，会生成一个JWT返回给用户。</p><h3 id="7-定义用户角色Role-java"><a href="#7-定义用户角色Role-java" class="headerlink" title="7.定义用户角色Role.java"></a>7.定义用户角色Role.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Role &#123;</span><br><span class="line">    MAINTAINER,</span><br><span class="line">    MANAGER,</span><br><span class="line">    PROCESSOR,</span><br><span class="line">    OPERATOR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统中一共有四种角色，定义一个枚举类。</p><h3 id="8-为每种角色定义权限注解"><a href="#8-为每种角色定义权限注解" class="headerlink" title="8.为每种角色定义权限注解"></a>8.为每种角色定义权限注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MaintainerToken &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种角色都对应一个权限注解，这些注解标注在Controller中的handler上，表示该handler有哪些角色具有请求权限。以上是Maintainer的权限注解@MaintainerToken，另外三个同上分别是@ManagerToken、@ProcessorToken、@OperatorToken。除此之外，还有第五个@PassToken，这个是通用注解，它标识的handler任何请求都可以访问，不需要权限验证。</p><h3 id="9-控制器UserController-java"><a href="#9-控制器UserController-java" class="headerlink" title="9.控制器UserController.java"></a>9.控制器UserController.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Mapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PassToken</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/user/signIn"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">signIn</span><span class="params">(@RequestBody SignInDTO signInDTO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String userId = signInDTO.getUserId();</span><br><span class="line">        String password = signInDTO.getPassword();</span><br><span class="line">        String token = userService.signIn(userId, password);</span><br><span class="line">        TokenDTO tokenDTO = TokenDTO.builder().token(token).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(tokenDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PassToken</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/user/signUp"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">signUp</span><span class="params">(@RequestBody UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">        User user = mapper.map(userDTO, User.class);</span><br><span class="line">        userService.signUp(user);</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试，只有运维人员和管理人员有权限访问的服务*/</span></span><br><span class="line">    <span class="meta">@MaintainerToken</span></span><br><span class="line">    <span class="meta">@ManagerToken</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/user/test"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">test</span><span class="params">(@RequestHeader(<span class="string">"token"</span>)</span> String token) </span>&#123;</span><br><span class="line">        String userId = JWTUtil.decodeUserId(token);</span><br><span class="line">        User user = userService.findUserById(userId);</span><br><span class="line">        UserDTO userDTO = mapper.map(user, UserDTO.class);</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图，每个handler哪些角色有权限访问，全部通过自定义的权限注解来实现。比如登录和注册handler有@PassToken注解，说明任何请求都可以访问它，不需要权限验证。测试handler有注解@MaintainerToken和@ManagerToken，说明只有Maintainer和Manager有权限访问它。</p><h3 id="10-定义一些DTO类"><a href="#10-定义一些DTO类" class="headerlink" title="10.定义一些DTO类"></a>10.定义一些DTO类</h3><p>可以看到控制器中的传输参数用的是DTO类，里面封装了和客户端进行传输的数据类型。使用Dozer进行实体类和DTO类之间的映射，从而方便地进行实体类和DTO类的相互转换。</p><h3 id="11-拦截器JWTInterceptor-java"><a href="#11-拦截器JWTInterceptor-java" class="headerlink" title="11.拦截器JWTInterceptor.java"></a>11.拦截器JWTInterceptor.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常发生后ErrorController的/error</span></span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"error"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有免验证令牌的handler</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(PassToken.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 检查token是否存在</span></span><br><span class="line">            String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">            <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(RespStatus.NON_TOKEN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 验证token是否合法</span></span><br><span class="line">            JWTUtil.verify(token);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查用户权限</span></span><br><span class="line">            Integer role = JWTUtil.decodeRole(token);</span><br><span class="line">            <span class="keyword">if</span>(role.equals(Role.MAINTAINER.ordinal())) &#123;</span><br><span class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(MaintainerToken.class)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(RespStatus.NON_AUTHORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(role.equals(Role.MANAGER.ordinal())) &#123;</span><br><span class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(ManagerToken.class)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(RespStatus.NON_AUTHORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(role.equals(Role.PROCESSOR.ordinal())) &#123;</span><br><span class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(ProcessorToken.class)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(RespStatus.NON_AUTHORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(role.equals(Role.OPERATOR.ordinal())) &#123;</span><br><span class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(OperatorToken.class)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(RespStatus.NON_AUTHORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthorityException(RespStatus.INVALID_TOKEN);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                           HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Object handler, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个拦截器是实现权限控制的核心模块。客户端过来的所有请求，会先被拦截器拦截下来，从这个请求头中拿出JWT，验证其合法性，并解码JWT中的用户权限字段role，然后比照role和所请求的handler的权限注解，如果符合权限要求，就释放这个请求到Controller层去处理，否则抛异常拦截掉这个请求。</p><h3 id="12-响应实体类Result-java"><a href="#12-响应实体类Result-java" class="headerlink" title="12.响应实体类Result.java"></a>12.响应实体类Result.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 状态码 */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 错误信息 */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回数据 */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证响应给前端的数据格式都具有统一的标准，定义响应实体类，由状态码、错误信息、数据三部分组成。</p><h3 id="13-状态码枚举类RespStatus-java"><a href="#13-状态码枚举类RespStatus-java" class="headerlink" title="13.状态码枚举类RespStatus.java"></a>13.状态码枚举类RespStatus.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span>(AccessLevel.PUBLIC)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RespStatus &#123;</span><br><span class="line">    SUCCESS(<span class="string">"200"</span>, <span class="string">"请求成功"</span>),</span><br><span class="line"></span><br><span class="line">    NON_AUTHORITY(<span class="string">"300"</span>, <span class="string">"不具备请求权限"</span>),</span><br><span class="line">    INVALID_TOKEN(<span class="string">"301"</span>, <span class="string">"令牌不合法"</span>),</span><br><span class="line">    NON_TOKEN(<span class="string">"302"</span>, <span class="string">"令牌不存在"</span>),</span><br><span class="line">    WRONG_PASSWORD(<span class="string">"303"</span>, <span class="string">"密码错误"</span>),</span><br><span class="line">    NON_ACCOUNT(<span class="string">"304"</span>, <span class="string">"账户不存在"</span>),</span><br><span class="line">    EXIST_ACCOUNT(<span class="string">"305"</span>, <span class="string">"账号已存在"</span>),</span><br><span class="line"></span><br><span class="line">    SERVER_ERROR(<span class="string">"400"</span>, <span class="string">"服务器错误"</span>),</span><br><span class="line"></span><br><span class="line">    UNKNOWN_ERROR(<span class="string">"500"</span>, <span class="string">"未知错误"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    RespStatus(String code, String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对响应实体类Result中的属性status和message，枚举类RespStatus定义了规范，根据响应状态，每个响应体对象都会与某个RespStatus对象绑定。</p><h3 id="14-响应工具类ResultUtil-java"><a href="#14-响应工具类ResultUtil-java" class="headerlink" title="14.响应工具类ResultUtil.java"></a>14.响应工具类ResultUtil.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.setStatus(RespStatus.SUCCESS.getCode());</span><br><span class="line">        result.setMessage(RespStatus.SUCCESS.getMessage());</span><br><span class="line">        result.setData(data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">error</span><span class="params">(RespStatus status)</span> </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.setStatus(status.getCode());</span><br><span class="line">        result.setMessage(status.getMessage());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于不同的响应情况，响应实体的构建是不一样的，为了避免在响应实体类Result中实现繁复的构造方法，实现一个响应工具类，根据具体情况快速构造响应体。可以看到，对于每个响应体对象的构建方法，某个RespStatus对象都会作为必要的输入参数。</p><h3 id="15-自定义异常类型"><a href="#15-自定义异常类型" class="headerlink" title="15.自定义异常类型"></a>15.自定义异常类型</h3><p>自定义了两个异常类型：AuthorityException&amp;&amp;ServiceException</p><p>（1）首先看AuthorityException.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span>(AccessLevel.PUBLIC)</span><br><span class="line"><span class="meta">@Setter</span>(AccessLevel.PUBLIC)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorityException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RespStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorityException</span><span class="params">(RespStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入了枚举对象RespStatus，说明每个AuthorityException对象都与一个特定的状态码枚举对象RespStatus绑定，标识这个异常发生后对应的响应状态。</p><p>AuthorityException全部在权限拦截器JWTInterceptor中抛出。</p><p>（2）再看ServiceException：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span>(AccessLevel.PUBLIC)</span><br><span class="line"><span class="meta">@Setter</span>(AccessLevel.PUBLIC)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String service; <span class="comment">// 发生异常的Service</span></span><br><span class="line">    <span class="keyword">private</span> RespStatus status; <span class="comment">// 异常状态码</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceException</span><span class="params">(RespStatus status, String service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与AuthorityException相同，也注入了枚举对象RespStatus。除此之外，还注入了一个String类型的service，用来标识该异常是在哪个Service中抛出的。</p><p>ServiceException全部在Service层抛出。</p><h3 id="16-全局异常处理类GlobalExceptionHandler-java"><a href="#16-全局异常处理类GlobalExceptionHandler-java" class="headerlink" title="16.全局异常处理类GlobalExceptionHandler.java"></a>16.全局异常处理类GlobalExceptionHandler.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MongoException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleMongoException</span><span class="params">(<span class="keyword">final</span> MongoException exception)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"Processing MongoException: &#123;&#125;"</span>, exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.error(RespStatus.SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(AuthorityException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleAuthorityException</span><span class="params">(<span class="keyword">final</span> AuthorityException exception)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"Processing  AuthorityException: &#123;&#125;"</span>, exception.getStatus().getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.error(exception.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ServiceException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleServiceException</span><span class="params">(<span class="keyword">final</span> ServiceException exception)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"Processing  ServiceException at "</span> + exception.getService() + <span class="string">": &#123;&#125;"</span>, exception.getStatus().getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.error(exception.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免在Controller层定义一堆的try……catch块来捕捉Service层抛出的异常，将异常处理和业务逻辑过程解耦，定义一个全局异常处理类。它不仅能捕获Service层抛出的异常，也能捕获权限拦截器JWTInterceptor抛出的异常，并对捕获的异常进行处理。</p><p><strong>一个坑：</strong>注意@ResponseBody这个注解一定要存在，表示每个handler的返回值是直接写到响应体中的，然后返回给客户端。如果没有这个注解，任何异常发生后，spring boot会自发一个’/error’的请求，映射到默认错误处理类ErrorController的’/error’对应的handler，这个默认方法会进行处理然后返回给客户端一个原生的响应体，覆盖掉我们自己在GlobalExceptionHandler里自定义构建的响应体。这个原生的响应体如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2019-10-30T07:53:11.228+0000"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">404</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Not Found"</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"No message available"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/user/test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此一定要使用@ResponseBody注解，将异常发生后的返回值直接写入响应体返回给客户端，spring boot就来不及自发这个’/error’请求了。</p><h2 id="三、效果演示"><a href="#三、效果演示" class="headerlink" title="三、效果演示"></a>三、效果演示</h2><p>前后端是RESTful的交互方式，因此使用Postman工具进行效果演示。</p><p>首先，注册一个用户：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gbae6xe1j31e80u0td0.jpg" alt></p><p>检查MongoDB的情况：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gaqlogkxj31ao0skgyh.jpg" alt></p><p>注册成功，现在用这个账户进行登录：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8garhvmdaj31e80u04kw.jpg" alt></p><p>登录成功后端返回了一串token，下次请求将这个token放在请求头中，注意/user/test接口的请求方法是GET：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gawnv3xwj31e80u0aut.jpg" alt></p><p>可以看到，用户的角色role为3，对应Role.OPERATOR，而/user/test接口上的注解是@MaintainerToken和@ManagerToken，说明只有Maintainer和Manager具有访问权限，而该用户权限不够。</p><p>重新注册一个role为1，对应Role.MANAGER的用户，登录后，请求/user/test接口：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gb3pf3nfj31e80u0wym.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gb4dlp5cj31e80u0qpk.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gb5ds222j31e80u04lf.jpg" alt></p><p>可以看到，这个用户具有访问接口/user/test的权限，请求成功。</p><p>把token的第一个字符’e’删掉，再发送请求，后端返回令牌不合法的错误响应：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gb7d3aiij31e80u04hm.jpg" alt></p><p>不带token，再发送请求，后端返回令牌不存在的错误响应：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gb8yzzk6j31e80u0qm0.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Web </tag>
            
            <tag> Token </tag>
            
            <tag> 登录 </tag>
            
            <tag> JWT </tag>
            
            <tag> MongoDB </tag>
            
            <tag> 权限控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo框架+Melody主题的个人博客使用记录</title>
      <link href="/2019/10/16/Hexo%E6%A1%86%E6%9E%B6+Melody%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/16/Hexo%E6%A1%86%E6%9E%B6+Melody%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于Hexo+GitHub Pages+Melody搭建了自己的个人博客，记录一下在使用过程中遇到的问题和解决方法</p></blockquote><a id="more"></a><ul><li>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li>Melody官方文档：<a href="https://molunerfinn.com/hexo-theme-melody-doc/" target="_blank" rel="noopener">https://molunerfinn.com/hexo-theme-melody-doc/</a></li><li>Melody主题开发者的主页：<a href="https://molunerfinn.com/" target="_blank" rel="noopener">https://molunerfinn.com/</a></li></ul><h2 id="1-Hexo解析的问题"><a href="#1-Hexo解析的问题" class="headerlink" title="1.Hexo解析的问题"></a>1.Hexo解析{{ }}的问题</h2><p>当Markdown正文中出现{{ }}的时候，Hexo会对其解析不正常，比如：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7zzjegv29j302s012741.jpg" alt></p><p>使用<code>hexo g</code>命令，报错：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7zzislqujj31aq0mie81.jpg" alt></p><p><strong>解决：</strong>在花括号两边分别加上：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7zzp180nuj30c00143yd.jpg" alt></p><p>使用<code>hexo g</code>命令，执行成功。</p><h2 id="2-Melody主题下某些页面去除评论功能"><a href="#2-Melody主题下某些页面去除评论功能" class="headerlink" title="2.Melody主题下某些页面去除评论功能"></a>2.Melody主题下某些页面去除评论功能</h2><p>我为博客添加了Gitalk评论插件，但是这样不仅每条博文下有了评论功能，标签页和分类页也被添加了评论功能：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g804iyyl99j30vd0u0myu.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g804mrgwx8j30ul0u0kev.jpg" alt></p><p>这显然不合理，因此想移除这两个页的评论功能。</p><p><strong>解决：</strong>很明显需要修改对应页面的生成模版，逻辑在/themes/melody/layout/page.pug：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  if page.type === &apos;tags&apos;</span><br><span class="line">    .tag-cloud</span><br><span class="line">      .tag-cloud__title= _p(&apos;page.tag&apos;)</span><br><span class="line">        |  - </span><br><span class="line">        span.tag-cloud__amount= site.tags.length</span><br><span class="line">      - var start_color = theme.theme_color ? (theme.theme_color.tag_start_color || &apos;#A4D8FA&apos;): &apos;#A4D8FA&apos;</span><br><span class="line">      - var end_color = theme.theme_color ? (theme.theme_color.tag_end_color || &apos;#1B9EF3&apos;) : &apos;#1B9EF3&apos;</span><br><span class="line">      .tag-cloud-tags!= tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color, end_color&#125;)</span><br><span class="line">    if page.comments !== false</span><br><span class="line">      include includes/comments/index.pug</span><br><span class="line">    </span><br><span class="line">  else if page.type === &apos;categories&apos;</span><br><span class="line">    #post-content</span><br><span class="line">      .category-lists</span><br><span class="line">        .category__title= _p(&apos;page.category&apos;)</span><br><span class="line">          |  - </span><br><span class="line">          span.category__amount= site.categories.length</span><br><span class="line">        div!= list_categories()</span><br><span class="line">    if page.comments !== false</span><br><span class="line">      include includes/comments/index.pug</span><br><span class="line">    </span><br><span class="line">  else if page.type === &apos;slides&apos;</span><br><span class="line">    include ./includes/mixins/slide.pug</span><br><span class="line">    +slideArticle()</span><br><span class="line">    if page.comments !== false</span><br><span class="line">      include includes/comments/index.pug</span><br><span class="line">  else</span><br><span class="line">    article#page</span><br><span class="line">      h1= page.title</span><br><span class="line">      .article-container!= page.content</span><br><span class="line">    include includes/pagination.pug</span><br><span class="line">    if page.comments !== false</span><br><span class="line">      include includes/comments/index.pug</span><br></pre></td></tr></table></figure><p>打开/source/tags/index.md：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g808rqknidj3186044t9e.jpg" alt></p><p>可以看见标签页的type属性为”tags”，因此删除12&amp;13行代码，即可移除标签页的评论功能。同理，分类页的type属性为”categories”，删除22&amp;23行代码可移除分类页的评论功能。效果如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g809oie6uoj312e0sawgu.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g809olryaxj315h0u0gnq.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Melody </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP课程笔记_02_OS_Structure</title>
      <link href="/2019/10/10/CSP%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_02_OS_Structure/"/>
      <url>/2019/10/10/CSP%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0_02_OS_Structure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《计算机系统原理》课程笔记(2)——夏虞斌老师——IPADS Lab</p></blockquote><a id="more"></a><h2 id="一、Operating-System、Kernel、Kernel-Mode、User-Mode"><a href="#一、Operating-System、Kernel、Kernel-Mode、User-Mode" class="headerlink" title="一、Operating System、Kernel、Kernel Mode、User Mode"></a>一、Operating System、Kernel、Kernel Mode、User Mode</h2><p>如何精确地定义操作系统(Operating System)？如何区分操作系统(OS)、内核(Kernel)、内核态(Kernel Mode)、用户态(User Mode)这些概念？操作系统就是内核吗？这些个问题看起来很简单也很基础，但涉及到答案却总是含糊其辞的。</p><p>对于操作系统的定义，我在网络上找到下面这些描述操作系统在计算机系统中位置的图片：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7te5i9qtpj30fo0f6tez.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7te665loyj311e0l6jy3.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7te70rb8rj31140o4176.jpg" alt></p><p>对于这三张图来说，它们都<strong>把操作系统看作是硬件层之上的、用户应用程序之下的软件，它控制计算机的硬件资源，并提供上层应用程序的运行环境</strong>。所有应用程序对硬件的操作都必须通过操作系统。首先明确加粗的这个操作系统定义是正确的。</p><p>目前对操作系统的具体定义有两种观点：</p><blockquote><p>1.当你预定一个操作系统时，零售商所给的所有东西就是操作系统。</p><p>2.内核才是操作系统。因为内核是一直运行在计算机上的程序，内核不运行则计算机无法运行。</p></blockquote><p>观点1最大化了操作系统，比如内置在操作系统中的应用程序比如IE浏览器等并不属于操作系统的组成部分，观点2最小化了操作系统，仅仅将内核视作操作系统，首先内核必是运行在内核态下的，但是对基于微内核(Micro kernel)的操作系统来说，将文件系统也放在了用户态下，这样文件系统将不再属于内核，但是文件系统依然属于操作系统的组成部分。</p><p>图二和图三对操作系统的定义显然属于观点2，即认为操作系统就是内核。在我看来，这样的定义对于基于宏内核(Monolithic Kernel)的操作系统(Linux等）来说<strong>似乎</strong>是解释得通的，但对于其他类型的操作系统来说，有一些模块虽然不在内核中（或者说运行于内核态下），而是运行在用户态下，但这些模块依然属于操作系统的组成部分，如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7tfaylwfkj313u0butcx.jpg" alt></p><p>然而即便是对于包含了操作系统一切程序模块的宏内核操作系统来说，“操作系统就是内核”这句话本身依旧是错误的，内核是操作系统的核心，内核一定是运行在内核态下的，而除了内核态，操作系统还提供了用户态作为其他程序的运行环境。这里就涉及到操作系统的“内核态”和“用户态”的概念。</p><p>一般的操作系统对程序的运行（运行的程序的实例即进程）权限进行分级，分别为用户态和内核态。内核态可以执行任何cpu指令，也可以引用任何内存地址，包括外围设备, 例如硬盘, 网卡，权限等级最高。用户态则权利有限，例如在进程的内存分配中，有一部分内存是仅为内核态下使用的，用户态code则不允许访问那些内存地址，而且用户态下进程只允许访问本进程被分配的内存空间，也不允许访问外围设备。</p><p>而内核中的程序模块只能运行在操作系统的内核态下，除此之外，用户态下依然会运行很多程序，对于宏内核操作系统来说，就是用户应用程序，对于微内核操作系统来说，就是用户应用程序以及很多从传统宏内核中抽出来的程序模块（如上图）。因此说操作系统就是内核显然是不对的。<strong>可以总结：运行在内核模式下（即内核中的）程序必然是属于操作系统的，但是运行在用户模式的程序也可能属于操作系统。</strong></p><p>用户应用程序跑在用户态下，但是如果需要执行一些权限不够的操作例如申请内存，网络读写时，就需要转换到内核态去让内核的code帮忙干一些事情，切换用户态到内核态有以下三种方式：</p><blockquote><p>1.系统调用</p><p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>2.异常</p><p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p><p>3.外围设备的中断</p><p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p></blockquote><p>系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断。从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p><h2 id="二、操作系统提供的抽象"><a href="#二、操作系统提供的抽象" class="headerlink" title="二、操作系统提供的抽象"></a>二、操作系统提供的抽象</h2><p>计算机系统的分层示图如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7u8w5sq5bj30wm07oq4x.jpg" alt></p><p>操作系统即用户应用程序和硬件层之间的一层软件，所有应用程序对硬件的操作都必须通过操作系统。</p><p>操作系统有以下两个基本功能：</p><blockquote><p>1.防止硬件被失控的应用程序滥用。</p><p>2.向应用程序提供简单一致的机制来控制复杂而又大相径庭的低级硬件设备。</p></blockquote><p>为了实现这两个基本功能，操作系统提供了<strong>三层抽象</strong>概念：文件、虚拟存储器和进程。文件是对I/O设备的抽象，虚拟存储器是对主存和I/O设备的抽象，进程是对处理器、主存、I/O设备的抽象。<strong>应用程序只需要和硬件的抽象接口打交道即可，而无需了解硬件的底层原理。</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7u96be3y3j30sm0cwmzb.jpg" alt></p><p><strong>文件</strong>就是1和0组成的字节序列，所有的I/O设备，包括磁盘、键盘、显示器、鼠标都可以看作文件。文件这个抽象概念向应用程序提供了一个精致又统一的视觉来看待所有I/O设备。</p><p><strong>虚拟存储器</strong>这个抽象概念为进程提供了一个假象，即进程在独占地使用主存，每个进程都看到一样大小的虚拟地址空间，并且自以为主存就和这个虚拟地址空间一样大，均只为自己所用。</p><p><strong>进程</strong>这个抽象概念也为进程提供了一个假象，即进程在独占地使用包括处理器、主存、I/O设备在内的所有硬件，自以为硬件从始自终都在只为自己服务。这实际上是由操作系统调度处理器在进程间进行切换来实现的，操作系统将这种切换机制称为上下文切换，由kernel实现。</p><p>PS：如果不仅仅考虑对硬件的抽象，而是从整个计算机系统的高度来看，还有更高层级的抽象：将操作系统以及计算机底层硬件抽象成一个虚拟机。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ubnedsa5j312w0f2q61.jpg" alt></p><h2 id="三、虚拟存储器-虚拟地址的意义"><a href="#三、虚拟存储器-虚拟地址的意义" class="headerlink" title="三、虚拟存储器/虚拟地址的意义"></a>三、虚拟存储器/虚拟地址的意义</h2><p>早起的计算机中没有虚拟存储器的概念，要运行一个程序，需要将程序全部装入内存，然后运行，当运行多个程序时会出现以下问题：</p><blockquote><p>1.进程地址空间不隔离，没有权限保护。由于程序都是直接访问物理内存，所以一个进程可以修改其他进程的内存数据，甚至修改内核地址空间中的数据。</p><p>2.内存使用效率低，当内存空间不足时，需要将其他程序的内存数据暂时拷贝到硬盘，然后将新的程序装入内存运行。由于大量的数据装入装出，内存使用效率十分低下。</p><p>3.程序运行的地址不稳定，因为内存地址是随机分配的，所以程序运行的地址也是不确定的。</p></blockquote><p>如上文所说，虚拟存储器其实就是操作系统对主存和I/O设备的抽象，让进程提供了一个在独占地使用主存的假象，而且进程看到的主存大小等于这个虚拟存储器的空间大小，即虚拟地址空间的大小。使用虚拟存储器的抽象有以下几个好处：</p><blockquote><p>1.隔离，保证主存中各个进程占用的空间互不干扰，不会出现属于本进程的主存数据被其他进程修改或覆盖的情况。</p><p>2.为每个进程都提供独立、<strong>连续</strong>且完整的地址空间（虚拟地址空间），给开发者分配、释放和访问内存地址带来方便。</p><p>3.提高内存利用率。针对2来说，如果将主存均等分成若干等大的块，每块分给一个进程使用，也能实现2的作用，但是这样做，一个进程对其分配的内存块经常是用不完的，自己用不了也不允许别人用，导致存在很多未使用的空闲空间。而虚拟存储空间的存在，使主存上的每一寸空间都允许被任何一个进程使用，提高了内存利用率。</p><p>4.控制物理内存的访问权限，数据安全性好。访问的虚拟页若没有读写权限，则触发一个保护异常，终止进程，对数据的访问进行保护，这是直接使用物理内存做不到的。</p></blockquote><h2 id="四、Exokernel"><a href="#四、Exokernel" class="headerlink" title="四、Exokernel"></a>四、Exokernel</h2>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 《计算机系统原理》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP课程笔记_01_Introduction</title>
      <link href="/2019/09/25/CSP%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-01-Introduction/"/>
      <url>/2019/09/25/CSP%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-01-Introduction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《计算机系统原理》课程笔记(1)——夏虞斌老师——IPADS Lab</p></blockquote><a id="more"></a><h2 id="一、Guessing-Password"><a href="#一、Guessing-Password" class="headerlink" title="一、Guessing Password"></a>一、Guessing Password</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">checkpw (user, passwd):</span><br><span class="line">      acct = accounts[user]</span><br><span class="line">      <span class="keyword">for</span> i in range(<span class="number">0</span>, len(acct.pw)):</span><br><span class="line">          <span class="keyword">if</span> acct.pw[i] ≠ passwd[i]:</span><br><span class="line">          <span class="keyword">return</span> False</span><br><span class="line">      <span class="keyword">return</span> True</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g75xr8idx2j31080dmgqh.jpg" alt></p><p>验证密码的代码逻辑是按顺序比照每一位，若相符则比照下一位，若不相符直接返回密码错误。</p><p>对于这种密码验证机制，可以采用<strong>Timing Attack</strong>（时序攻击）来破解密码。一开始的思路是：验证程序运行的时间越长，则说明猜中密码的位数越多。但是计算机的运算速度太快，程序对每一个字符的验证都用极短且不可确定的时间完成，而且因为计算机运行的不确定性，程序在不同次的实验过程中对同一个字符的验证时间也不一定相同，因此通过运行总时间来量化地推测猜对密码位数不可行。</p><p>正确思路是基于操作系统的寻址特性之一<strong>Page Fault</strong>（缺页）。每次只猜一个字符，将猜测的字符及之前的所有已通过验证的正确字符放在映射到主存的Page中，剩下的字符放在未映射到主存的Page中。如果该猜测字符通过了验证，则读下一个字符的时候会发生Page Fault，而Page Fault带来的时间损失是能够被明显观测到的，程序的运行总时间会大幅增加。因此，每次观测到Page Fault的出现，都说明猜测字符通过了验证，以此类推便能猜测出完整的密码。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g75z1lfptfj31f60nq416.jpg" alt></p><h2 id="二、C语言中volatile关键字"><a href="#二、C语言中volatile关键字" class="headerlink" title="二、C语言中volatile关键字"></a>二、C语言中volatile关键字</h2><p>在本线程内读取内存中一个变量时，为提高存取速度，编译器的优化会将变量读取到一个寄存器中，下次再读取这个变量值时，就不会从内存中读，而是直接从寄存器中取值。</p><p>当变量值在本线程内被改变时，会同时更新寄存器中的值，使寄存器和内存保持一致。但当变量在别的线程中被改变时，寄存器内的值不会被更新，则下次本线程从寄存器读到的值就和其实际内存中的值不一样，即<strong>内存比寄存器/缓存的值要新</strong>。</p><p>为了拿到内存中最新的值，使用volatile关键字，被这个关键字修饰的变量每次读都是从内存中读，不会因为编译器的优化而从寄存器或者缓存中读。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 《计算机系统原理》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性之Option类</title>
      <link href="/2018/09/29/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOption%E7%B1%BB/"/>
      <url>/2018/09/29/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOption%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大三暑假实习的技术分享</p></blockquote><a id="more"></a><h2 id="一、Java8以往版本的不足"><a href="#一、Java8以往版本的不足" class="headerlink" title="一、Java8以往版本的不足"></a>一、Java8以往版本的不足</h2><p>在以往版本的Java中，对于调用某个方法得到的的返回对象，不能直接调用该对象的某方法。而是应该首先判断该对象是否为null，只有在其不为null的前提下才可以调用其方法，否则会引起空指针异常。</p><p>这种对对象是否为null的判断是显式的，这样就会在代码中的各个地方出现if(xxx != null)的判断语句，造成代码污染。</p><p>而在Java8中新出现的Optional类对null判定提供了一种更加优雅的实现。</p><h2 id="二、读源码"><a href="#二、读源码" class="headerlink" title="二、读源码"></a>二、读源码</h2><h3 id="（1）成员变量"><a href="#（1）成员变量" class="headerlink" title="（1）成员变量"></a>（1）成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Optional类是一个集合类，但是每个optional对象内却只有1个元素。一个optional对象中可以引用一个T类型的对象，或者一个空指针。</p><h3 id="（2）构造方法"><a href="#（2）构造方法" class="headerlink" title="（2）构造方法"></a>（2）构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.value = <span class="keyword">null</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">this</span>.value = Objects.requireNonNull(value); &#125;</span><br></pre></td></tr></table></figure><p>Optional的构造方法是私有的，因此不允许直接new一个optional实例。Optional提供3个静态方法来构造optional对象：</p><h4 id="①Optional-of-T-value"><a href="#①Optional-of-T-value" class="headerlink" title="①Optional.of(T value)"></a>①Optional.of(T value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value); &#125;</span><br></pre></td></tr></table></figure><p>通过传入一个非null的value对象来构造一个optional，若传入参数为 null，会抛出 NullPointerException。</p><p>通常在两种情况下使用：非常确定 value 参数不不可能为 null 时；想为 value 断言不不为 null 时，及想在value 为 null 时立即抛出异常。</p><h4 id="②Optional-empty"><a href="#②Optional-empty" class="headerlink" title="②Optional.empty()"></a>②Optional.empty()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用来构造一个空的 optional，即该optional中的value为null。如果在一个 Optional.empty 上调用get() 方法，会抛出 NoSuchElementException 异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"No value present"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③Optional-ofNullable-T-value"><a href="#③Optional-ofNullable-T-value" class="headerlink" title="③Optional.ofNullable(T value)"></a>③Optional.ofNullable(T value)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value); &#125;</span><br></pre></td></tr></table></figure><p>该方法是以上两种方法的并集，如果传入value是一个对象，调用of()方法构造，如果传入的是null，调用empty()方法构造。</p><h3 id="（3）常用方"><a href="#（3）常用方" class="headerlink" title="（3）常用方"></a>（3）常用方</h3><h4 id="①isPresent"><a href="#①isPresent" class="headerlink" title="①isPresent()"></a>①isPresent()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value != <span class="keyword">null</span>; &#125;</span><br></pre></td></tr></table></figure><p>判断optional内持有的对象是否为空。</p><h4 id="②orElse"><a href="#②orElse" class="headerlink" title="②orElse()"></a>②orElse()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123; <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other; &#125;</span><br></pre></td></tr></table></figure><p>如果 Optional 中持有非空对象则将其返回，否则返回传入的参数。</p><h4 id="③懒得写了，嘻嘻"><a href="#③懒得写了，嘻嘻" class="headerlink" title="③懒得写了，嘻嘻"></a>③懒得写了，嘻嘻</h4>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慎用Collection的add()接口</title>
      <link href="/2018/09/18/%E6%85%8E%E7%94%A8Collection%E7%9A%84add()%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/09/18/%E6%85%8E%E7%94%A8Collection%E7%9A%84add()%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大三暑假实习遇到的的问题记录</p></blockquote><a id="more"></a><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>实习时写过下面一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;ISynchro&gt; allISynchros = synchroCache.values(); <span class="comment">// synchroCache是HashMap</span></span><br><span class="line">Collection&lt;ISynchro&gt; npcISynchros = synchroNpcCache.values(); <span class="comment">// synchroNpcCache是HashMap</span></span><br><span class="line">allISynchros.addAll(npcISynchros);</span><br></pre></td></tr></table></figure><p>运行时抛出java.lang.UnsupportedOperationException异常。</p><h2 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h2><p>Collection接口的实现与继承关系如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7wiyeoj7ij30fi0e63zd.jpg" alt></p><p>AbstractCollection是Java集合框架中Collection接口的直接实现类，Collection的子接口的实现类大都继承AbstractCollection，比如AbstractList和AbstractSet。</p><p>AbstractCollection实现了几个方法，也定义了几个抽象方法留给子类实现，因此是一个抽象类。两个抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>此外，注意add()和addAll()方法的实现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation always throws an</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException            &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException          &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException      &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException         &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation iterates over the specified collection, and adds</span></span><br><span class="line"><span class="comment">     * each object returned by the iterator to this collection, in turn.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that this implementation will throw an</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; unless &lt;tt&gt;add&lt;/tt&gt; is</span></span><br><span class="line"><span class="comment">     * overridden (assuming the specified collection is non-empty).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException            &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException          &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException      &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException         &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #add(Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果调用AbstractCollection的add()或addAll()方法，将抛出Unsupported OperationException异常。因此如果子类需要add的功能，需要重写add()方法。</p><p>文章开头的代码中synchroCache和synchroNpcCache均为HashMap,查看源代码，发现HashMap的values()方法实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> Values();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出values()方法返回的vs属于Values内部类，该类继承自AbstractCollection，而且并未重写add()方法。因此如果对返回值调用addAll()或者add()方法，依然会抛出UnsupportedOperationException异常。因此今后在实际使用中要避免HashMap.values().add()&amp;HashMap.values.addAll()。</p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>那么如果需要合并两个AbstractCollection该如何操作？</p><p><strong>方案（1）</strong>将Collection转List，首先尝试强转的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ISynchro&gt; allISynchros = (List&lt;ISynchro&gt;)synchroCache.values();</span><br></pre></td></tr></table></figure><p>强转报错java.lang.ClassCastException。因为Collection是List的父接口，而强制类型转换只能完成向上转型，即子类对象转为父类对象，反过来不行，因为子类有的方法父类可能没有。但将List向上转型为Collection是可行的。</p><p>后来看到ArrayList有个构造函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以接受一个Collection的参数，返回一个List，实现了将Collection转换为List，满足要求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ISynchro&gt; allISynchros = <span class="keyword">new</span> ArrayList&lt;ISynchro&gt;(synchroCache.values());</span><br><span class="line">List&lt;ISynchro&gt; npcISynchros = <span class="keyword">new</span> ArrayList&lt;ISynchro&gt;(synchroNpcCache.values());</span><br></pre></td></tr></table></figure><p>之后再调用ArrayList的addAll()方法即可。ArrayList的add()方法是重写的，实现了add功能，不会抛异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allISynchros.addAll(npcISynchros);</span><br></pre></td></tr></table></figure><p><strong>方案（2）</strong>使用CollectionUtils.union(collection1，collection2)方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;ISynchro&gt; allISynchros = synchroCache.values();</span><br><span class="line">Collection&lt;ISynchro&gt; npcISynchros = synchroNpcCache.values();</span><br><span class="line">CollectionsUtils.union(allISynchros, npcISynchros);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>停止Java线程的方法</title>
      <link href="/2018/09/18/%E5%81%9C%E6%AD%A2Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/09/18/%E5%81%9C%E6%AD%A2Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大三暑假实习的技术分享</p></blockquote><a id="more"></a><h2 id="一、使用stop-方法（已弃用）"><a href="#一、使用stop-方法（已弃用）" class="headerlink" title="一、使用stop()方法（已弃用）"></a>一、使用stop()方法（已弃用）</h2><p>（1）stop()方法相当于关掉计算机的电源，这是极度危险的，因为我们难以定位线程是执行到什么位置被关闭的，为以后的维护带来麻烦。</p><p>（2）stop()方法会破坏原子逻辑。多线程为了解决共享资源抢占的问题，使用了锁的概念，避免资源不同步。执行stop()方法后被关闭的线程会丢弃所有的锁，导致原子逻辑受损，原来被锁保护的共享资源将处于不连贯的状态，可能导致不安全的操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="string">" "</span>) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            a--;</span><br><span class="line">            String str = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(str + <span class="string">":a = "</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.stop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-5 : a = 1</span><br><span class="line">Thread-4 : a = 1</span><br><span class="line">Thread-3 : a = 1</span><br><span class="line">Thread-2 : a = 1</span><br><span class="line">Thread-1 : a = 1</span><br></pre></td></tr></table></figure><p>Task实现Runnable借口，synchronized代码块内部是原子逻辑，a的值会先增加后减小，无论开多少个线程，打印出的结果应该都是a=0。但如果有一个正在执行的线程被stop()，就可能破坏这种原子逻辑。</p><p>第一个线程thread在synchronized代码块未执行完毕就被stop掉，将a的值改为1，由于a是共享变量，因此其他五个线程都打印a=1。stop()方法破坏了原子逻辑，造成了数据不同步。</p><h2 id="二、使用volatile标志位"><a href="#二、使用volatile标志位" class="headerlink" title="二、使用volatile标志位"></a>二、使用volatile标志位</h2><p>一般run()方法执行完，线程就会正常结束。然而，常常有些线程是伺服线程，它们需要长时间的运行，在外部某些条件满足的情况下，才能关闭这些线程。一般使用一个变量控制while循环。例如，最直接的方法就是设置一个boolean类型的标志位，并通过设置这个标志为true或false来控制while循环是否退出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!exit) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用volatile关键字的作用：</p><blockquote><p><strong>保证不同线程对这个共享变量的可见性，即一个线程改变了共享变量的值，这个新值对其他线程来说是立即可见的。</strong></p><p>Java的内存模型规定所有的变量存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7wjv01dvxj30fi07hjsg.jpg" alt></p><p>因为执行线程必须先在自己的工作缓存中进行赋值操作，然后再写入主存，而不是直接写入主存。这样就会出现缓存不一致的问题，一个线程对共享变量进行修改之后，还未写入主存，其他线程是不可见的，读出的值可能依然是旧值，即多线程编程中的脏读。</p><p>而当使用volatile关键字之后，被修饰的共享变量被修改后会立即写入主存，并导致该变量在其他线程中的缓存失效，从而致使其他线程再次读取该变量时会从主存中读取。即一个线程改变了共享变量的值，这个新值对其他线程来说是立即可见的。</p></blockquote><h2 id="三、使用interrupt-中断的方式"><a href="#三、使用interrupt-中断的方式" class="headerlink" title="三、使用interrupt()中断的方式"></a>三、使用interrupt()中断的方式</h2><p>（1）线程处于阻塞状态，如使用了sleep方法。当调用interrupt()时，会抛出InterruptException异常。可以在代码中捕获这个异常，然后break跳出循环，从而退出run()方法，结束线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>); <span class="comment">// 阻塞5秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 捕获到异常后，执行break跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）线程未处于阻塞状态，使用isInterrupted()来判断线程的中断标志来退出循环。当使用interrupt()方法时，isInterrupted()就会返回true，和使用自定义的标志位控制循环是一样的原理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）值得注意的是，对阻塞状态的线程使用interrupt()，会抛出Interrupted Exception异常，还会将中断位先置为true再复位为false，如果此时不通过break退出线程，那么等到线程变为运行状态之后，再通过isInterrupted()获得的中断位将是false，无法退出线程。所以使用interrupt()来退出线程的最好的方式应该是两种情况都要考虑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123; <span class="comment">// 非阻塞状态时通过判断中断标志来退出</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>); <span class="comment">// 阻塞5秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123; <span class="comment">// 阻塞状态下通过捕获中断异常来退出</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不管线程当前处于运行状态或是阻塞状态，执行interrupt()方法后都会退出。</p>]]></content>
      
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java字符串常量池</title>
      <link href="/2018/09/17/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2018/09/17/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大三暑假实习的技术分享</p></blockquote><a id="more"></a><h2 id="一、设计思想"><a href="#一、设计思想" class="headerlink" title="一、设计思想"></a>一、设计思想</h2><p>为字符串开辟一个字符串常量池，创建字符串常量时，首先检测字符串常量池是否存在该字符串。如存在该字符串对象，返回其引用；若不存在，实例化该字符串并放入常量池中，并返回其引用。</p><h2 id="二、实现基础"><a href="#二、实现基础" class="headerlink" title="二、实现基础"></a>二、实现基础</h2><p>（1）String类字符串实例化后的对象是不可变的，初始化是什么则这个对象就永远是什么，相当于是常量，因此String的对象们可以维护成一个常量池。</p><p>（2）运行时字符串常量池中有一个表，总是为池中所有的字符串对象维护一个引用，所以常量池中的这些字符串不会被GC回收。</p><h2 id="三、操作常量池的情况"><a href="#三、操作常量池的情况" class="headerlink" title="三、操作常量池的情况"></a>三、操作常量池的情况</h2><blockquote><p>凡是” “形式定义的字符串一定会操作常量池。</p><p>不满足上面的情况，但是被编译成String str = “ “形式的，会操纵常量池（从中取该常量，如果取不到，就创建一个）</p></blockquote><h3 id="（1）直接赋值"><a href="#（1）直接赋值" class="headerlink" title="（1）直接赋值"></a>（1）直接赋值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"Java"</span>;</span><br></pre></td></tr></table></figure><p>当”Java”字符串对象已经存在于常量池中时，str直接指向常量池中的对象。如果不存在，在常量池中创建”Java”，令str指向它。</p><h3 id="（2）运算符重载"><a href="#（2）运算符重载" class="headerlink" title="（2）运算符重载"></a>（2）运算符重载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"Ja"</span> + <span class="string">"va"</span>;</span><br></pre></td></tr></table></figure><p>Java中可以使用+进行两个字符串的拼接。会被直接编译成str = “Java”，会操作常量池。事实上这句话在常量池中创建了3个对象：”Ja”、”va”、”Java”（如果常量池中原本没有这些对象）。</p><p>注意，如果是下面的情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String temp = <span class="string">"va"</span>;</span><br><span class="line">String str = <span class="string">"Ja"</span> + temp;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"Ja"</span> + <span class="keyword">new</span> String(<span class="string">"va"</span>);</span><br></pre></td></tr></table></figure><p>此时str不会在编译时不会被自动拼接，即不会被编译成str = “Java”的形式，也就不会在常量池中创建”Java”的对象。但是还是会在常量池中创建”Ja”和”va”。</p><h2 id="四、图形化的例子"><a href="#四、图形化的例子" class="headerlink" title="四、图形化的例子"></a>四、图形化的例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String m = <span class="string">"hello,world"</span>;</span><br><span class="line">String n = <span class="string">"hello,world"</span>;</span><br><span class="line">String u = <span class="keyword">new</span> String(m);</span><br><span class="line">String v = <span class="keyword">new</span> String(<span class="string">"hello,world"</span>);</span><br></pre></td></tr></table></figure><p>1.会分配一个11长度的char[ ]对象[‘h’,’e’,’l’,’l’,’o’,’,’,’w’,’o’,’r’,’l’,’d’]，并在常量池分配一个由这个char数组组成的字符串对象”hello,world”，然后由m去引用这个字符串。<br>2.用n去引用常量池里边的字符串”hello,world”，所以和m引用的是同一个对象。<br>3.在堆中生成一个新的字符串，但内部的字符数组引用着m内部的字符数组。看一下源码就比较直观了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a newly created &#123;<span class="doctag">@code</span> String&#125; object so that it represents</span></span><br><span class="line"><span class="comment">     * the same sequence of characters as the argument; in other words, the</span></span><br><span class="line"><span class="comment">     * newly created string is a copy of the argument string. Unless an</span></span><br><span class="line"><span class="comment">     * explicit copy of &#123;<span class="doctag">@code</span> original&#125; is needed, use of this constructor is</span></span><br><span class="line"><span class="comment">     * unnecessary since Strings are immutable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  original</span></span><br><span class="line"><span class="comment">     *         A &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.同样会在堆中生成一个新的字符串，但内部的字符数组引用常量池里边的字符串”hello,world”内部的字符数组，也就是m/n内部字符数组。</p><p>使用图来表示的话，情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系):</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7wk2x5lotj30bi07d3yc.jpg" alt></p><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String m = <span class="string">"hello,world"</span>;</span><br><span class="line">String n = <span class="string">"hello,world"</span>;</span><br><span class="line">String u = <span class="keyword">new</span> String(m);</span><br><span class="line">String v = <span class="keyword">new</span> String(<span class="string">"hello,world"</span>);</span><br><span class="line">            </span><br><span class="line">System.out.println(m == n); <span class="comment">//true </span></span><br><span class="line">System.out.println(m == u); <span class="comment">//false</span></span><br><span class="line">System.out.println(m == v); <span class="comment">//false</span></span><br><span class="line">System.out.println(u == v); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="五、String的equals-和intern"><a href="#五、String的equals-和intern" class="headerlink" title="五、String的equals()和intern()"></a>五、String的equals()和intern()</h2><p>（1）在Java中用==判断左右两边非基本数据类型的引用，是指判断两个引用是否是引用同一个对象。String的equals()方法则是判断两个字符串内部引用的字符数组对象的值是否相同（注意不要求是引用同一个数组对象）。源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this string to the specified object.  The result is &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * true&#125; if and only if the argument is not &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * String&#125; object that represents the same sequence of characters as this</span></span><br><span class="line"><span class="comment">     * object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  anObject</span></span><br><span class="line"><span class="comment">     *         The object to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the given object represents a &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment">     *          equivalent to this string, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>  #compareTo(String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>  #equalsIgnoreCase(String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（2）intern()方法：如果常量池中有与本字符串相同的（equals）字符串，就直接返回池中对象的引用，如果没有就在常量池中创建该对象并返回其引用。源码的注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">     * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">     * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">     * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>因此对两个字符串使用intern()和==，也可以起到和equals()一样的功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String m = <span class="keyword">new</span> String(<span class="string">"xixi"</span>);</span><br><span class="line">String n = <span class="keyword">new</span> String(<span class="string">"xixi"</span>);</span><br><span class="line">System.out.println(m.intern() == n.intern()); <span class="comment">// true</span></span><br><span class="line">System.out.println(m.equals(n)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的String&amp;StringBuilder&amp;StringBuffer</title>
      <link href="/2018/07/21/Java%E7%9A%84String&amp;StringBuilder&amp;StringBuffer/"/>
      <url>/2018/07/21/Java%E7%9A%84String&amp;StringBuilder&amp;StringBuffer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大三暑假实习的技术分享</p></blockquote><a id="more"></a><h2 id="一、String类源码分析"><a href="#一、String类源码分析" class="headerlink" title="一、String类源码分析"></a>一、String类源码分析</h2><h3 id="1-String类的主要成员属性："><a href="#1-String类的主要成员属性：" class="headerlink" title="1. String类的主要成员属性："></a>1. String类的主要成员属性：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）String类是final关键字修饰的，即意味着String类不能被继承，并且它的成员方法都默认为final方法。因为在Java中，被final关键字修饰的类不允许被继承，且该类的所有成员方法都默认为final方法。final方法不可以被（该类的子类）覆盖（override）。<br>（2）String通过私有成员char value[ ]数组保存字符串。</p><h3 id="2-String类的一些方法实现："><a href="#2-String类的一些方法实现：" class="headerlink" title="2. String类的一些方法实现："></a>2. String类的一些方法实现：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">        <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = count;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">        <span class="keyword">int</span> off = offset;   <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[off + i] == oldChar) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; j++) &#123;</span><br><span class="line">            buf[j] = val[off+j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = val[off + i];</span><br><span class="line">            buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, len, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>从以上的substring、concat、replace三个方法可以看出，返回的字符串都是一个重新new的一个String对象，也就是说这些操作并不是在当前的字符串上进行修改的。总结为下面这句话：</p><blockquote><p>对String对象的任何改变都影响不到原对象，相关的任何change操作都会生成新的对象。</p></blockquote><h2 id="二、String、StringBuilder、StringBuffer的区别"><a href="#二、String、StringBuilder、StringBuffer的区别" class="headerlink" title="二、String、StringBuilder、StringBuffer的区别"></a>二、String、StringBuilder、StringBuffer的区别</h2><h3 id="1-执行速度方面"><a href="#1-执行速度方面" class="headerlink" title="1.执行速度方面"></a>1.执行速度方面</h3><p>首先来看下面这段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            string += <span class="string">"hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译的字节码如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7wka1b19tj30ht0h8dh5.jpg" alt></p><p>在上图字节码中，从第8行到第35行是源代码中循环语句string+= “hello”的执行过程，每次执行都会new一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(string);</span><br><span class="line">str.append(<span class="string">"hello"</span>);</span><br><span class="line">str.toString();</span><br></pre></td></tr></table></figure><p>StringBuilder类的toString方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// Create a copy, don't share the array  </span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也需要new一个String的对象，因此循环1000次将造成巨大的内存浪费，且执行速度很慢。</p><p>再看以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译字节码文件得到：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7wkark5lyj30ht0e40tm.jpg" alt><br>&emsp;&emsp;</p><p>字节码的13行到27行是源代码循环的执行过程，其中并没有任何new的操作，即append操作都是在原有对象的基础上进行的，因此循环1000次占用的内存资源要小得多，执行速度也更快。</p><p>三者的执行效率StringBuilder&gt;StringBuffer&gt;String，当然这个是相对的，也有例外情况，比如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line">StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure><p>String的速度比StringBuilder的反应速度快很多，因为对于直接相加字符串，在编译器便确定了它的值，也就是说”abc”+”de”的字符串相加，在编译期间便被优化成了”abcde”。对于间接相加（即包含字符串引用），形如s1+s2+s3，效率要比直接相加低，因为在编译器不会对引用变量进行优化。</p><h3 id="2-线程安全方面"><a href="#2-线程安全方面" class="headerlink" title="2.线程安全方面"></a>2.线程安全方面</h3><p>StringBuilder和StringBuffer类所拥有的成员属性和成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字synchronized，因此StringBuffer是线程安全的，StringBuilder是非线程安全的。下面摘了两段代码分别来自二者的insert方法的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> str[], <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.insert(index, str, offset, len);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> str[], <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.insert(index, str, offset, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-适用情况"><a href="#3-适用情况" class="headerlink" title="3.适用情况"></a>3.适用情况</h3><blockquote><p>String：适用于少量字符串操作的情况<br>StringBuilder：适用于单线程下对大量字符串操作<br>StringBuffer：适用于多线程下对大量字符串操作</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拼多多研发实习岗笔试题回顾</title>
      <link href="/2018/07/15/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%A0%94%E5%8F%91%E5%AE%9E%E4%B9%A0%E5%B2%97%E7%AC%94%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/"/>
      <url>/2018/07/15/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%A0%94%E5%8F%91%E5%AE%9E%E4%B9%A0%E5%B2%97%E7%AC%94%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大三暑假找拼多多研发实习岗的笔试题</p></blockquote><a id="more"></a><h2 id="一、编程题"><a href="#一、编程题" class="headerlink" title="一、编程题"></a>一、编程题</h2><p>1.输入是一个只含有 0 和 1 的二维矩阵，每一行都是排过序的，也就是说每一行前一部分都是 0，剩下的全都是 1。请找哪些行包含的 1 最多。要求对于 MxN 的矩阵，时间复杂度是O(M+N)，空间复杂度是 O(1)。</p><p>示例:</p><p>[0 0 0 0 0 0 0 1 1 1 1 1 ]</p><p>[0 0 0 0 1 1 1 1 1 1 1 1 ]</p><p>[0 0 0 0 0 0 1 1 1 1 1 1 ]</p><p>[0 0 0 0 0 0 0 0 0 1 1 1 ]</p><p>[0 0 0 0 0 0 0 1 1 1 1 1 ]</p><p>[0 0 0 0 1 1 1 1 1 1 1 1 ]</p><p>对于上面的函数，第 2 行和第 6 行都有 8 个 1。所以输出[2,8] 和 [6,8]。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by loumoon on 2018/7/15.</span></span><br><span class="line"><span class="comment"> * 我的思路是用一个数组rowMax保存有最多1的行。指针从这个矩阵的右上角开始，</span></span><br><span class="line"><span class="comment"> * 如果当前数为1且左边数也为1，指针向左移一个位置，且清空rowMax；</span></span><br><span class="line"><span class="comment"> * 如果当前数为1且左边数为0，或者左边已经没有数了，把当前行存进rowMax，然后指针向下移动一个位置；</span></span><br><span class="line"><span class="comment"> * 如果当前数为0，指针向下移动一个位置。</span></span><br><span class="line"><span class="comment"> * 这样遍历完后，rowMax中就保存了所有拥有最多1的行索引，1的个数可以用总列数减去遍历结束后的列索引</span></span><br><span class="line"><span class="comment"> * 得到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findRow(<span class="keyword">int</span> [][] array) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<span class="comment">//保存返回结果</span></span><br><span class="line">        <span class="keyword">int</span> rows=array.length;<span class="comment">//总行数</span></span><br><span class="line">        <span class="keyword">if</span>(rows==<span class="number">0</span>)<span class="keyword">return</span> result;<span class="comment">//输入空矩阵，返回空的result即可</span></span><br><span class="line">        <span class="keyword">int</span> columns=array[<span class="number">0</span>].length;<span class="comment">//总列数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;<span class="comment">//行指针</span></span><br><span class="line">        <span class="keyword">int</span> column=columns-<span class="number">1</span>;<span class="comment">//列指针，从右上角开始</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; rowMax=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">//保存拥有最多1的行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(row&lt;=rows-<span class="number">1</span>&amp;&amp;column&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">/*当前位置为1且左边为0，或者左边已经没有数了(说明这一行全都是1)，注意||左右两边表达式的判断顺序，如果反过来会抛出超出索引的异常*/</span></span><br><span class="line">            <span class="keyword">if</span>(array[row][column]==<span class="number">1</span>&amp;&amp;(column==<span class="number">0</span>||array[row][column-<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">                rowMax.add(row);<span class="comment">//说明在当前情况下，这是一个有最多1的行</span></span><br><span class="line">                row++;<span class="comment">//指针下移</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*当前位置为1且左边为1，说明此时找到了1更多的行，*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[row][column]==<span class="number">1</span>&amp;&amp;array[row][column-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                rowMax.clear();<span class="comment">//清空，说明之前的最多1数目的记录已经被刷新了</span></span><br><span class="line">                column--;<span class="comment">//指针左移</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[row][column]==<span class="number">0</span>)&#123;</span><br><span class="line">                row++;<span class="comment">//当前行的1数达不到最高纪录，淘汰</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMax=columns-column;<span class="comment">//最多1数的记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowMax.size();i++)&#123;</span><br><span class="line">            List singleRow=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            singleRow.add(rowMax.get(i));</span><br><span class="line">            singleRow.add(numMax);</span><br><span class="line">            result.add(singleRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=findRow(array);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.输入一个字符串比如{[(2+3)(1-3)] + 4}(14-3)，分析它的括号使用是否正确，括号有三种：小括号()，中括号[]，大括号{}</p><p>正确的括号使用必须满足以下条件(和数学上定义一致):</p><p>(1)左右括号必须匹配</p><p>(2)每一种类型括号只能和同一类型的括号匹配，即(和)匹配 [和]匹配 {和}匹配</p><p>(3)括号有优先级，小括号在最内层，中括号必须嵌套在小括号外面，大括号必须嵌套在中括号外面</p><p>(4)比如{},([ ])这样的都是非法的</p><p>(5)除了最外层可以连续嵌套大括号外，小括号和中括号不能连续嵌套，比如(( )),[[( )]]都是非法的，但是{{[( )]}}是合法的</p><p>(6)不需要考虑除了括号之外的其他字符是否违反了数学上的规定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by loumoon on 2018/7/14.</span></span><br><span class="line"><span class="comment"> * 注意题设要求的：小括号在最内层，中括号必须嵌套在小括号外面，大括号必须嵌套的中括号外面，也就是说</span></span><br><span class="line"><span class="comment"> * 出现了大括号，其内部一定得有中括号，出现了中括号，其内部一定得有小括号。</span></span><br><span class="line"><span class="comment"> * 因此不仅需要入栈之前对栈顶进行检测，而且还要对之后的入栈情况进行检测。比如入栈了左大括号，在右大</span></span><br><span class="line"><span class="comment"> * 括号闭合之前要检测是否有中括号出现，若没有则不合法。同理如果入栈了左中括号，在右中括号闭合之前要</span></span><br><span class="line"><span class="comment"> * 检测是否有小括号出现，若没有则不合法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bracketsJudge</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> hasMiddleBrackets=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasLittleBrackets=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;string.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur=string.charAt(i);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;(stack.peek()==<span class="string">'['</span>||stack.peek()==<span class="string">'('</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hasMiddleBrackets=<span class="keyword">true</span>;<span class="comment">//如果有大括号出现，其后面必有跟着的中括号才不合法</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">'['</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;(stack.peek()==<span class="string">'['</span>||stack.peek()==<span class="string">'('</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hasMiddleBrackets=<span class="keyword">false</span>;<span class="comment">//出现了中括号，置为false</span></span><br><span class="line">                hasLittleBrackets=<span class="keyword">true</span>;<span class="comment">//如果有中括号出现，其后面必有跟着的小括号，否则不合法</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;(stack.peek()==<span class="string">'('</span>||stack.peek()==<span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hasLittleBrackets=<span class="keyword">false</span>;<span class="comment">//出现了小括号，置为false</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasMiddleBrackets==<span class="keyword">true</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//大括号闭合之前依然没有出现中括号，不合法</span></span><br><span class="line">                <span class="keyword">if</span>(stack.pop()!=<span class="string">'&#123;'</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasLittleBrackets==<span class="keyword">true</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//中括号闭合之前依然没出现小括号，不合法</span></span><br><span class="line">                <span class="keyword">if</span>(stack.pop()!=<span class="string">'['</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop()!=<span class="string">'('</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> check=bracketsJudge(<span class="string">""</span>);</span><br><span class="line">        System.out.println(check);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.房间里面有一个机器人位于位置(0, 0)。房间的形状和面积都是未知的。你可以通过一个遥控器来控制机器人往前后左右四个方向中的任何一个移动一个格子。</p><p>移动的函数是 boolean move(int direction), direction: 0, 1, 2, 3。如果机器人发现移动方向上被墙壁挡住，这个方法会返回 false，否则这个函数就会返回 true，机器人就会移动到相应的位置。</p><p>请实现一个函数，来找到房间的面积。注:房间的形状是不规则的，但是是由许多大小为 1x1 的格子组成的，比如下图表示的房子里面，每一个 X 表示一个格子，房间的总面积是 10</p><p>X</p><p>XXX X </p><p>XXXXX</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by loumoon on 2018/7/14.</span></span><br><span class="line"><span class="comment"> * 深度优先搜索，将不重复地走过的所有的位置保存在集合set中，遍历结束后set的size就是房间面积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quadrature</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; record=<span class="keyword">new</span> HashSet&lt;String&gt;();<span class="comment">//集合存储到达过的位置，位置用字符串表示</span></span><br><span class="line">        recursion(record,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//进行递归</span></span><br><span class="line">        <span class="keyword">return</span> record.size();<span class="comment">//递归完毕后所有的位置都被遍历了，集合中的元素个数就是面积</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*递归*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(Set&lt;String&gt; set,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        set.add(x+<span class="string">","</span>+y);<span class="comment">//当前位置加入集合</span></span><br><span class="line">        <span class="keyword">if</span>(!set.contains(x+<span class="string">","</span>+(y+<span class="number">1</span>))&amp;&amp;move(x,y,<span class="number">0</span>))&#123;<span class="comment">//向上</span></span><br><span class="line">            recursion(set,x,y+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!set.contains(x+<span class="string">","</span>+(y-<span class="number">1</span>))&amp;&amp;move(x,y,<span class="number">1</span>))&#123;<span class="comment">//向下</span></span><br><span class="line">            recursion(set,x,y-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!set.contains((x-<span class="number">1</span>)+<span class="string">","</span>+y)&amp;&amp;move(x,y,<span class="number">2</span>))&#123;<span class="comment">//向左</span></span><br><span class="line">            recursion(set,x-<span class="number">1</span>,y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!set.contains((x+<span class="number">1</span>)+<span class="string">","</span>+y)&amp;&amp;move(x,y,<span class="number">3</span>))&#123;<span class="comment">//向右</span></span><br><span class="line">            recursion(set,x+<span class="number">1</span>,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*这个move()自定义的，是测试用的*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dir)</span></span>&#123;<span class="comment">//判断从(x,y)位置往dir方向是否可行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.给定 K 个有序数组 a1, a2, … , ak，求一个最小长度的区间 [s, t],使得每个数列 ai 都至少有一个元素 aij 在这个区间内。如果有多个长度相等的区间满足条件，则选择起始点 s 最小的那一个。<br>示例:</p><p>​    输入:[1, 3, 5] [4, 8] [2, 5]</p><p>​    输出: [4, 5]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by loumoon on 2018/7/15.</span></span><br><span class="line"><span class="comment"> * 找到所有数组最小值中的最大值，和所有数组最大值中的最小值，分别作为所求区间的最小值和最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findInterval</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=input.get(<span class="number">0</span>).get(<span class="number">0</span>);<span class="comment">//保存所有数组最小值中的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max=input.get(<span class="number">0</span>).get(input.get(<span class="number">0</span>).size()-<span class="number">1</span>);<span class="comment">//保存所有数组最大值中的最小值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;input.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input.get(i).get(<span class="number">0</span>)&gt;min)&#123;</span><br><span class="line">                min=input.get(i).get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(input.get(i).get(input.get(i).size()-<span class="number">1</span>)&lt;max)&#123;</span><br><span class="line">                max=input.get(i).get(input.get(i).size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min&gt;max)&#123;<span class="comment">//如果min&gt;max，交换二者的值</span></span><br><span class="line">            <span class="keyword">int</span> exch=min;</span><br><span class="line">            min=max;</span><br><span class="line">            max=exch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        result.add(min);</span><br><span class="line">        result.add(max);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、问答题"><a href="#二、问答题" class="headerlink" title="二、问答题"></a>二、问答题</h2><h3 id="1-请简述线程和进程的区别"><a href="#1-请简述线程和进程的区别" class="headerlink" title="1.请简述线程和进程的区别"></a>1.请简述线程和进程的区别</h3><p>（1）进程是一个执行中的程序的实例。具有独立的逻辑控制流和私有的地址空间，提供一个抽象，好像应用程序在独占地使用处理器和存储器系统。线程自己基本不拥有系统资源，运行时只是暂用一些计数器、寄存器和栈。</p><p>（2）一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</p><p>（3）进程之间相互独立，但同一进程下的各个线程之间共享进程的内存空间。 </p><p>（4）线程上下文切换比进程上下文切换要快得多。</p><h3 id="2-请简述抢占式和非抢占式进程的区别"><a href="#2-请简述抢占式和非抢占式进程的区别" class="headerlink" title="2.请简述抢占式和非抢占式进程的区别"></a>2.请简述抢占式和非抢占式进程的区别</h3><p>非抢占式进程调度就是让进程运行到结束或阻塞的调度方式。采用非抢占式进程调度，当就绪队列中某进程的最高优先级高于正在处理器中运行的进程的最高优先级时，并不会让正在运行的进程退出处理器，而是将更高优先级的进程排在就绪队列的首部。</p><p>抢占式进程调度是允许将逻辑上可继续运行的进程暂停的调度方式，可防止单一进程长时间独占CPU。采用抢占式最高优先级进程调度，更高优先级的进程会直接抢占处理器，让正在处理的进程强制退出处理器，处于就绪队列。</p><h3 id="3-两个不同的线程之间如何通信？两个进程之间呢？"><a href="#3-两个不同的线程之间如何通信？两个进程之间呢？" class="headerlink" title="3.两个不同的线程之间如何通信？两个进程之间呢？"></a>3.两个不同的线程之间如何通信？两个进程之间呢？</h3><p>（1）线程之间的通信方式：</p><p>–共享变量。线程可以在共享对象的变量里设置信号值，从而实现在线程间的信号发送。</p><p>–wait()\notify机制。可以使用Object类提供的wait()、notify()、notifyAll()三个方法。</p><p>–管道。但是管道流只能在两个线程之间传递数据。而且管道流只能实现单向发送，如果要两个进程之间相互通讯，需要两个管道流。</p><p>（2）进程间的通信方式</p><p>–管道。管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</p><p>–命名管道。命名管道除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p>–信号。</p><p>–消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。</p><p>–共享内存。使得多个进程可以访问同一块内存空间，是最快的可用进程间通信形式。</p><h4 id="4-如何实现一个线程安全的hash-map？"><a href="#4-如何实现一个线程安全的hash-map？" class="headerlink" title="4.如何实现一个线程安全的hash map？"></a>4.如何实现一个线程安全的hash map？</h4><p>线程安全的hash map有HashTable和ConcurrentHashMap，二者相对于HashMap都具有线程安全的优点。</p><p>HashTable使用synchronized同步锁，使同一时间仅有一个线程能拿到锁并更改HashTable，因此其缺点是效率低。</p><p>ConcurrentHashMap则将内部分为若干个segment，每次操作对segment加锁，保证每个segment是线程安全的，从而保证整个ConcurrentHashMap是线程安全的，因此若干个线程可同时访问并更改ConcurrentHashMap，其相对于HashTable效率更高。</p>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
